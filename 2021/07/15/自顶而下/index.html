<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="第一章 计算机网络与因特网 什么是因特网？ 两种回答方式：①能够描述因特网的具体构成，即构成因特网的基本硬件和软件组成；②能够根据为分布式应用提供服务的联网基础设施来描述因特网。  对①的描述： 因特网应用程序运行在端系统上，也就是它们并不运行在网络核心中的分组交换机中。即使分组交换机能够加速端系统间的数据交换，但它们并不在意作为数据的源或宿的应用程序。  对②的描述： 将因特网描述为应用程序的平">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2021/07/15/%E8%87%AA%E9%A1%B6%E8%80%8C%E4%B8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第一章 计算机网络与因特网 什么是因特网？ 两种回答方式：①能够描述因特网的具体构成，即构成因特网的基本硬件和软件组成；②能够根据为分布式应用提供服务的联网基础设施来描述因特网。  对①的描述： 因特网应用程序运行在端系统上，也就是它们并不运行在网络核心中的分组交换机中。即使分组交换机能够加速端系统间的数据交换，但它们并不在意作为数据的源或宿的应用程序。  对②的描述： 将因特网描述为应用程序的平">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-07-15T13:17:17.581Z">
<meta property="article:modified_time" content="2021-07-15T09:10:39.980Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 5.4.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://github.com/IcoveJ/MyBlog/blob/master/01.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/"></a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://github.com/IcoveJ/MyBlog/blob/master/01.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-自顶而下" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2021/07/15/%E8%87%AA%E9%A1%B6%E8%80%8C%E4%B8%8B/" class="article-date">
  	<time datetime="2021-07-15T13:17:17.581Z" itemprop="datePublished">2021-07-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第一章-计算机网络与因特网"><a href="#第一章-计算机网络与因特网" class="headerlink" title="第一章 计算机网络与因特网"></a>第一章 计算机网络与因特网</h1><ul>
<li><p>什么是因特网？</p>
<p>两种回答方式：①能够描述因特网的具体构成，即构成因特网的基本硬件和软件组成；②能够根据为分布式应用提供服务的联网基础设施来描述因特网。</p>
<ul>
<li><p>对①的描述：</p>
<p>因特网应用程序运行在端系统上，也就是它们并不运行在网络核心中的分组交换机中。即使分组交换机能够加速端系统间的数据交换，但它们并不在意作为数据的源或宿的应用程序。</p>
</li>
<li><p>对②的描述：</p>
<p>将因特网描述为应用程序的平台。</p>
</li>
</ul>
</li>
<li><p>因特网服务提供商：ISP</p>
<p>每个ISP自身就是一个由多台<strong>分组交换机</strong>和多段<strong>通信链路</strong>组成的网络</p>
</li>
<li><p>分布式应用：涉及多个相互交换数据的端系统的应用程序</p>
</li>
<li><p>运行在一个端系统上的应用程序怎么样才能指令因特网向运行在另一个端系统上的软件发送数据呢？</p>
<p>通过<strong>套接字接口</strong>，该接口规定了运行在另一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的地程序交付数据的方式。</p>
<p>因特网套接字接口是一套发送程序必须遵循的规则集合。</p>
</li>
<li><p>协议：定义了在<strong>两个</strong>或<strong>多个通信实体</strong>之间交换的报文的<strong>格式</strong>和<strong>顺序</strong>，以及报文发送和/或接收一条报文或其他事件所采取的动作。</p>
</li>
<li><p>端系统：桌面计算机、服务器、移动计算机</p>
</li>
<li><p>主机 = 端系统，但对主机的分类是：客户（client）和服务器（server）。</p>
</li>
<li><p>家庭接入网的方式有：DSL，电缆，FTTH，拨号，卫星。</p>
<ul>
<li><p>宽带住宅接入的两种类型：数字用户线（DSL）和电缆。</p>
<p>关于DSL，每个用户的<strong>DSL调制解调器</strong>使用现有的电话线与位于本地中心局（OC）的<strong>数字用户线接入复用器</strong>（DSLAM）交换数据。家庭的DSL调制解调器将得到的数字数据转化成高频音，来自家庭的模拟信号在DSLAM处被转换成数字形式。</p>
<p>每个用户能接网所依托的就是现有的<strong>电话线</strong>，它同时承载着数据和传统的电话信号，并使用不同的频率进行编码：</p>
<ul>
<li><p>高速下行信道：位于50kHz到1MHz频段；</p>
</li>
<li><p>中速上行信道：位于4kHz到50kHz频段；</p>
</li>
<li><p>普通的双向电话信道：位于0到4kHz频段；</p>
<p>（ex：上行信道是指用户发给基站所经历的信道，下行信道与之相反）</p>
</li>
</ul>
</li>
<li><p>电缆因特网接入利用的是<strong>有线电视基础设施</strong>，依托的是<strong>混合光纤同轴系统（HFC）</strong>：<strong>光缆</strong>连接地区枢纽和电缆头端，<strong>同轴光缆</strong>连接每个家庭与电缆头端。</p>
</li>
<li><p>FTTH-光纤到户：关于光纤分布方案，有两种：<strong>有源光纤网络（AON）</strong>，<strong>无源光纤网络（PON）</strong>。</p>
<ul>
<li><p>AON：本质上是交换以太网</p>
</li>
<li><p>PON：在PON中，每个家庭具有一个光纤网络端接器（ONT），由专门的光纤连接到邻近的分配器，这个分配器再把一些家庭集结到一根共享的光纤，这根光纤再连接到本地电话和公司的中心局中的光纤线路端接器（OLT）。OLT提供了光信号与电信号之间的转换。</p>
<p>在PON体系结构中，所有从OLT发送到分配器的分组在分配器。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>物体媒介的作用：对于每个发射器-接收器对，通过跨越一种物理媒介传播电磁波或光脉冲来发送该比特。</p>
<p>分为两种类型：<strong>导引型媒体</strong>和<strong>非导引型媒体</strong>。前者例如光缆、双绞铜线、同轴电缆，后者例如电波在空气或外层空间中传播</p>
<p>对于导引型媒体：</p>
<ul>
<li>双绞铜线：是高速LAN联网的主导型解决方案，其中无屏蔽双绞线（UTP）常用于局域网LAN。目前局域网的数据传输速率取决于双绞线的粗细以及传输方和接收方间的距离。</li>
<li>同轴电缆：由两个铜导体组成，但它们是同心的而不是并行的</li>
<li>光纤：每个脉冲表示一个比特，且不受电磁干扰，所以被用做长途导引型传输媒体，特别是跨海链路。</li>
</ul>
<p>对于非导引型媒体：</p>
<ul>
<li>陆地无线电信道：极大地依赖于传播环境和信号传输距离。环境上的考虑取决于①路径损耗和遮挡衰落②多径衰落③干扰</li>
<li>卫星无线电信道：同步卫星和近地轨道</li>
</ul>
</li>
<li><p>网络核心：由<strong>互联因特网端系统</strong>的<strong>分组交换机</strong>和<strong>链路</strong>构成的<strong>网状网络</strong>。</p>
</li>
<li><p>通过网络链路和交换机移动数据有两种基本方法：<strong>分组交换</strong>和<strong>电路交换</strong></p>
<ul>
<li><p>分组交换：分组的定义是——为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块。在源与目的地之间，每个分组都通过<strong>通信链路</strong>和<strong>分组交换机</strong>（交换器主要有两类：<strong>路由器</strong>和<strong>链路层交换机</strong>）。每一个分组都以等于该链路最大传输速率的速度传输通过通信链路。</p>
<ul>
<li><p>存储转发传输：是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。</p>
<p>通过由N条速率均为R的链路组成的路径（也就是在源和目的地之间有N-1台路由器），从源到目的地发送一个分组，那么端到端的时延是：<br>$$<br>d_{端到端} = N\frac{L}{R}<br>$$</p>
</li>
<li><p>排队时延和分组丢失：对于每条相连的链路，该分组交换机具有一个<strong>输出缓存</strong>（或者是<strong>输出队列</strong>），用于存储路由器准备发往那条链路的分组。由于网络的拥塞程度的不同，<strong>排队时延</strong>也是会变化的。同时由于缓存空间的大小是有限的，一个到达的分组可能就会发现该缓存已被其他等待传输的分组充满，这就会导致<strong>分组丢失（丢包）</strong>——到达的分组或者已经排队的分组之一将被丢弃。</p>
</li>
<li><p>转发表和路由转发协议：每台路由器都有一个<strong>转发表</strong>，用于将目的地址（或目的地址的一部分）映射成为输出链路。而这些转发表的设置是<strong>由路由转发协议</strong>来自动设置。</p>
</li>
</ul>
</li>
<li><p>电路交换：电路交换与分组交换最大的区别就是<strong>在端系统间通信会话期间，是否预留了端系统间沿路径通信所需要的资源</strong>，在电路交换网络中是要预留的，在分组交换中则不会。在电路交换中也常常会使用到复用技术，主要有<strong>频分复用（FDM）</strong>和<strong>时分复用（TDM）</strong></p>
<ul>
<li>频分复用（FDM）：链路的频谱由跨越链路创建的所有连接共享，特别是，在连接期间链路为每条连接专用一个频段。</li>
<li>时分复用（TDM）：对于一条TDM链路，时间被划分为固定期间的帧，并且每个帧又被划分为固定数量的时隙。这些时隙专门由该连接单独使用，一个时隙可用于传输该连接的数据。对于TDM，一条电路的传输速率等于帧速率乘以一个时隙中的比特数量。</li>
</ul>
</li>
</ul>
<p>在当今电信网络中，分组交换和电路交换都是普遍采用的方式，但都是朝着分组交换的方向发展。原因是：电路交换不考虑需求，而预先分配了传输链路的使用，这就会使得已分配而并不需要的链路时间未被利用；相反，分组交换按需分配链路使用，链路传输能力将在所有需要在链路上传输分组的用户之间逐分组被共享。</p>
</li>
<li><p>因特网的网络结构</p>
<p>互联接入ISP的中心目标是使所有端系统能够彼此发送分组。</p>
<p><strong>网络结构1</strong>：用单一的全球传输ISP互联所有接入ISP。接入ISP被认为是客户，全球传输ISP被认为是提供商。</p>
<p><strong>网络结构2</strong>：由数十万接入ISP和多个全球传输ISP组成。要注意的是所有的全球传输ISP之间必须是互联的。</p>
<p><strong>网络结构3</strong>：这是一个多层等级结构，与今天的因特网粗略的相似。每个接入ISP向其连接的区域ISP支付费用，并且每个区域ISP向它连接的第一层ISP支付费用。</p>
<p><strong>网络结构4</strong>：是在等级化网络结构3的基础上增加<strong>存在点（PoP）</strong>、<strong>多宿</strong>、<strong>对等</strong>和<strong>因特网交换点（IXP）</strong>。PoP存在于等级结构的所有层次（底层等级除外）。一个PoP只是提供商网络中的一台或多台路由器群组。任何ISP（除了第一层ISP）都可以选择<strong>多宿</strong>，即可以与两个或更多提供商ISP连接。当一个ISP多宿时，即使它的提供商之一出现了故障，仍然能够继续发送和接收分组。客户ISP向提供商ISP支付的费用数额反映了它通过提供商交换的通信流量。为了减少这些开销，位于相同等级结构层次的邻近一对ISP能够<strong>对等</strong>，也就是能够直接将它们的网络连接到一起，使得两者的流量数据能够直接连接而不是通过上游的中间ISP传输。当两个ISP实现对等时，不进行任何的结算。所以说，网络结构4是由接入ISP、区域ISP、第一层ISP、PoP、多宿、对等和IXP组成。</p>
<p><strong>网络结构5</strong>：也就是今天的因特网。通过在网络结构4顶部增加<strong>内容提供商网络</strong>构建而成。通过创建自己的网络，内容提供商不仅能够减少向顶层ISP支付的费用，而且对其服务最终如何交付给端用户有了更多的控制。</p>
</li>
<li><p>分组交换网中的时延：<strong>节点处理时延</strong>、<strong>排队时延</strong>、<strong>传输时延</strong>、<strong>传播时延</strong>。</p>
<ul>
<li>节点处理时延：包括检查分组首部和决定该分组导向何处所需要的时间、检查比特级别的差错所需要的时间。</li>
<li>排队时延：一个特定分组的排队时延长度将取决于先期到达的正在排队等待向链路传输的分组数量。</li>
<li>传输时延：将所有分组的比特推向链路所需要的时间。</li>
<li>传播时延：在链路上传输分组所需要的时间。</li>
</ul>
<p>传输时延和传播时延的区别在于：前者是分组长度与链路传输速率的函数，后者是链路长度与链路传输速率的函数。</p>
<p>节点的总时延等于上述四个时延的和。</p>
</li>
<li><p>什么时候排队时延大？什么时候又不大？</p>
<p>取决于流量到达该队列的速率、链路的传输速率和到达流量的性质，即流量是周期性到达还是以突发形式到达。</p>
<p>设a表示分组到达队列的平均速率（单位是分组/秒，即pkt/s），R是队列的传输速率，即从队列中推出比特的速率（以bps为单位），同时假定所有分组都是由L比特组成。那么就能够得到<strong>流量强调</strong>的表达式：<br>$$<br>\frac{La}{R}<br>$$<br>流量强度是设计系统的一个重要指标——在流量工程中有一条金科定律：设计系统时流量强度不能大于1。并且，随着流量强度接近于1，平均排队时延迅速增加</p>
</li>
<li><p>关于<strong>丢包</strong>，从端系统的角度来看，似乎是一个分组已经传输到网络核心了，但它绝不会再从网络发送到目的地。并且，分组丢失的比例会随着流量强度增加而增加。基于此，一个节点的性能就不是根据时延来度量，而是根据丢包的概率来度量。</p>
<p>但是丢失的分组<strong>可能</strong>基于端到端的原则及逆行重传，以确保所有的数据最终从源传送到了目的地。</p>
</li>
<li><p>在今天因特网中对吞吐量的限制因素通常是接入网。</p>
</li>
<li><p>协议分层：为了给网络协议的设计提供一个结构，网络设计者以<strong>分层</strong>的方式组织协议以及实现这些协议的网络硬件和软件。协议分层具有<strong>概念化</strong>和<strong>结构化</strong>的优点。但也有一个潜在的缺点：一层可能冗余较低层的功能，同时某层的功能可能需要仅在其他某层才出现的信息，这违反了层次分离的目标。</p>
<p>因特网的协议栈由5个层次组成：物理层、链路层、网络层、运输层、应用层。</p>
<ul>
<li>应用层：是网络应用程序及它们的应用层协议存留的地方，协议包括HTTP、SMTP、FTP等。我们将位于应用层的信息分组称为<strong>报文</strong>。</li>
<li>运输层：在应用程序端点之间传送应用层报文。在因特网中有两种运输协议：TCP与UDP。<ul>
<li>TCP向它的应用程序提供了面向连接的服务，这种服务包括了应用层报文向目的地确保传递和流量控制（即发送方/接收方速率匹配）</li>
<li>UDP协议向它的应用程序提供无连接的服务。这是一种不提供不必要服务的服务，没有可靠性，没有流量控制，也没有拥塞控制。</li>
</ul>
</li>
<li>网络层：负责将称为数据报的网络层分组从一台主机移动到另一台主机。这一层包括了著名的网际协议IP，它定义了在数据报中的各个字段以及端系统和路由器如何做用于这些字段。也包括了路由选择协议等。</li>
<li>链路层：由链路层提供的服务取决于应用于该链路的特定链路层协议。链路层的分组被称为帧</li>
<li>物理层：将帧中的一个个比特从一个节点移动到下一个节点。这一层中的协议是链路相关的，并且进一步与该链路的实际传输媒体相关。</li>
</ul>
</li>
<li><p>OSI的七层模型：应用层、表示层、会话层、运输层、网络层、数据链路层、物理层。相较于五层结构，新增了表示层和会话层——表示层：使通信的应用程序能够解释交换数据的含义，这些服务包括数据压缩、数据加密、数据描述；会话层：提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。</p>
</li>
<li><p>数据的封装成帧：在发送主机端，一个<strong>应用层报文</strong>被传输给运输层，在运输层会被加上一个首部信息（设为$H_t$）成为<strong>运输层报文段</strong>；再被传输给网络层，在网络层加上一个首部信息（设为$H_n$）成为<strong>网络层数据报</strong>；再被传输给链路层，在链路层加上一个首部信息（设为$H_l$）成为<strong>链路层帧</strong>。最后这个帧被传输给物理层通过物理媒介传输。</p>
</li>
<li><p>病毒：一种需要某种形式的用户交互来感染用户设备的恶意软件。</p>
</li>
<li><p>蠕虫：一种无需任何明显用户交互就能进入设备的恶意软件。</p>
</li>
<li><p>拒绝服务攻击：也即是DoS攻击。它能够使得网络、主机或其他基础设施部分不能由合法用户使用。大多数因特网DoS攻击属于下面三种：</p>
<ul>
<li>弱点攻击：这涉及向一台目标主机上运行的易受攻击的应用程序或操作系统发送制作精细的报文。如果适当顺序的多个分组发送给一个易受攻击的应用程序或操作系统，该服务可能停止运行，或者更糟糕的是主机可能崩溃。</li>
<li>带宽洪泛：向目标主机发送大量的分组来造成目标的接入链路变得拥塞，以使合法的分组无法到达服务器。</li>
<li>连接洪泛：攻击者在目标主机中创建大量的半开或全开TCP连接，以使目标主机因这些伪造的连接而陷入困境，并停止接受合法的连接。</li>
</ul>
<p>目前最广泛地应该是DDoS，分布式拒绝服务攻击：攻击者痛过控制多个源并让每个源向目标猛烈发送流量。</p>
</li>
</ul>
<h1 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章 应用层"></a>第二章 应用层</h1><ul>
<li><p>研发网络应用程序的核心是写出能够运行在不同端系统和通过网络彼此通信的程序。</p>
</li>
<li><p>应用程序体系结构由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序。</p>
</li>
<li><p>现代应用程序中所使用的两种主流体系结构是：<strong>客户-服务器体系结构</strong>，<strong>对等（P2P）结构</strong></p>
<ul>
<li>客户-服务器体系结构：客户相互之间不直接通信，同时该服务具有固定的、周知的地址，这个地址被称为IP地址。这类的著名应用程序包括：Web、FTP、Telnet和电子邮件。</li>
<li>P2P体系结构：对位于数据中心的专用服务器有最小的依赖。它最好的特性是<strong>自扩展性</strong>。</li>
</ul>
</li>
<li><p> 进程通信：一个进程可以被理解为是运行在端系统中的一个程序。当多个进程运行在相同的端系统上时，它们使用进程间通信机制相互通信。它的规则由端系统上的操作系统确定。在两个不同端系统上的进程，通过跨越计算机网络<strong>交换报文</strong>而相互通信：发送进程生成并向网络中发送报文，接收进程接受收这些报文并可能通过回送报文进行响应。</p>
</li>
<li><p>客户和服务器进程：在每队通信进程中，将两个进程之一标识为客户，另一个进程标识为服务器。在客户-服务器体系结构中，客户和服务器是严格区分开的，但在P2P结构中，一个进程是既可以是客户又可以是服务器的。于是对二者的定义就为：</p>
<ul>
<li>客户：在一对进程之间的通信会话场景中，发起通信的进程被标识为客户。</li>
<li>服务器：在会话开始时等待联系的进程是服务器。</li>
</ul>
</li>
<li><p>进程通过一个称为<strong>套接字</strong>的软件接口向网络发送报文和从网络接收报文。套接字是同一台主机内<strong>应用层和运输层</strong>之间的接口，是建立网络应用程序的可编程接口，所以也被称为应用程序和网络之间的<strong>应用程序编程接口（API）</strong>。应用程序开发者对于运输层的控制仅限于：①选择运输层协议②也许能够设定几个运输层参数。</p>
</li>
<li><p>为了标识一个接收进程，需要定义两种信息：①主机的地址②在目的主机中指定接收进程的标识符。在因特网中主机由<strong>IP地址</strong>标识</p>
</li>
<li><p>一个运输层协议能够为调用它的应用程序提供什么样的服务？从四个方面对应用程序服务要求进行分类：可靠数据传输、吞吐量、定时和安全性。</p>
<ul>
<li>可靠数据传输：如果一个协议提供了一端发送的数据正确、完全地交付给该应用程序的另一端的数据交付服务，就认为提供了可靠数据传输。当一个运输层协议无法提供可靠数据传输时，由发送进程发送的某些数据就可能到达不了接收进程，但这或许能被<strong>容忍丢失的应用</strong>所接受，例如一些播放音视频的软件，丢失的数据对它们会产生小干扰，但不会出现致命伤。</li>
<li>吞吐量：在这种服务下，应该程序能够请求一定值的比特/秒的确保吞吐量，并且运输协议能够确保可用吞吐量总是至少为这个值。具有吞吐量要求的应用程序被称为<strong>带宽敏感的应用</strong>，<strong>弹性应用</strong>能够根据当是可用的带宽或多或少地利用可供使用的吞吐量。</li>
<li>定时：这种服务对交互式实时应用程序有吸引力，比如因特网电话、电话会议、网络游戏等，这些应用为了有效性而要求数据交付有严格的时间限制。但对于非实时的应用，较低的时延总比较高的时延好，而且对端到端的时延没有严格地约束。</li>
<li>安全性：是否对传输的数据进行加密处理。</li>
</ul>
</li>
<li><p>TCP服务模型：包括面向连接的服务和可靠数据传输服务：</p>
<ul>
<li>面向连接的服务：在应用层数据报文开始流动之前，TCP会让客户和服务器进行”握手“（握手阶段），互相交换运输层控制信息。之后一个<strong>TCP连接</strong>就在两个进程的套接字之间建立了。这条连接的<strong>全双工的（即连接双方的进程可以在此连接上同时进行报文收发）</strong>。当应用程序结束报文发送时，该连接必须拆除。</li>
<li>可靠的数据传送服务：通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。在字节被套接字交付的过程中，是没有字节的丢失和冗余的。</li>
<li>此外还具有拥塞控制机制。这种服务不见得能够为通信进程带来直接的好处，但能为因特网带来整体好处。</li>
</ul>
</li>
<li><p>UDP服务模型：是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。因为UDP是无连接的，所以在两个进程通信前没有握手过程。同时它提供的也是不可靠数据传输服务，也就是当发送进程将报文发送进UDP套接字时，UDP协议并不保证该报文将到达接收进程。UDP也是没有拥塞控制的，所以可以用它选定的任何速率向其下层（即网络层）注入数据。</p>
</li>
<li><p>应用层协议：这些协议定义了运行在不同端系统上的应用程序进程是如何相互传递报文的。特别是定义了：</p>
<ul>
<li>交换的报文类型：例如请求报文和响应报文。</li>
<li>各种报文类型的语法：例如报文中的各个字段及这些字段是如何描述的</li>
<li>字段的语义</li>
<li>确定一个进程何时以及如何发送报文，对报文进行响应的规则。</li>
</ul>
</li>
<li><p>应用层协议只是网络应用的一部分。</p>
</li>
<li><p>Web与HTTP：Web的应用层协议就是<strong>超文本传输协议HTTP</strong>，它是Web的核心。HTTP由两个程序实现：一个客户程序和一个服务器程序。它们俩运行在不同的端系统中，通过交换HTTP报文进行对话。它定义了这些报文的结构以及客户和服务器进行报文交换的方式。</p>
<ul>
<li>HTTP定义了Web客户向Web服务器请求Web页面的方式，以及服务器向客户传送Web页面的方式，其基本方式是：当用户请求一个Web页面时（比如点击一个链接），浏览器向服务器发出对该页面所包含对象的HTTP请求报文，服务器接收到请求并用包含这些对象的HTTP响应报文进行响应。</li>
<li>HTTP是将TCP作为它的支撑运输协议：HTTP客户首先发起一个与服务器的TCP连接，一旦连接建立起，该浏览器和服务器进程就可以通过套接字接口访问TCP</li>
<li>HTTP是一个<strong>无状态协议</strong>，所以HTTP服务器并不保存关于客户的任何信息。</li>
<li>Web是使用了客户-服务器应用程序体系结构，Web服务器总是打开的，具有一个固定的IP地址，且它服务于可能来自数以百万计的不同浏览器请求。</li>
</ul>
</li>
<li><p>HTTP与客户如何解释一个Web页面毫无关系，HTTP规范仅定义了在HTTP客户程序与HTTP服务器程序之间的通信协议。</p>
</li>
<li><p>往返时间RTT：指一个短分组从客户到服务器然后再返回客户所花费的时间。它包括了分组传播时延、分组在中间路由器和交换机上的排队时延，分组处理时延。</p>
</li>
<li><p>采用非持续连接的HTTP：每一个请求/响应对是经一个单独的TCP连接发送。但有一些缺点：①必须为每一个请求的对象建立和维护一个全新的连接。对于每一个这样的连接，在客户和服务器中都要分配TCP缓冲区和TCP变量，这就会给Web服务器带来严重的负担；②每一个对象会经受两倍RTT的交付时延，即一个RTT用于创建TCP，另一个RTT用于请求和接收一个对象。</p>
</li>
<li><p>采用持续连接的HTTP：所有的请求及其响应经相同的TCP连接发送。与非持续连接的HTTP不同的是，持续连接下，服务器在发送响应后保持该TCP连接的打开。一个完整的Web页面可以用单个持续TCP连接进行传送；位于同一台服务器的多个Web页面在从该服务器发送给同一个客户时，也可以在单个持续TCP连接上进行。</p>
<p>在这种情况下，对对象的请求可以一个接一个的发出，而不需要等待对未决请求的回答。在实际中，若一条连接经过一定的时间间隔仍未被使用，那么HTTP服务器仍然会关闭这条连接。</p>
</li>
<li><p>HTTP的报文格式：HTTP的主要报文有两种——请求报文和响应报文：</p>
<ul>
<li><p><strong>请求报文</strong>：请求报文的第一行叫作<strong>请求行</strong>，其后继的行叫作<strong>首部行</strong>（首部行所提供的信息是Web代理高速缓存所要求的）</p>
<p>①请求行有三个字段：方法字段、URL字段、HTTP版本字段</p>
<ul>
<li><strong>方法字段</strong>：有五种取值——GET、POST、HEAD（服务器不会返回请求对象）、PUT（允许用户上传对象到指定的Web服务器上的指定路径）、DELETE（允许用户或者应用程序删除Web服务器上的对象）</li>
<li><strong>URL字段</strong>：请求对象的标识，也即虚拟目录部分</li>
<li><strong>HTTP版本字段</strong>：由其自解释得到</li>
</ul>
<p>②首部行包括但不限于：</p>
<ul>
<li><strong>Host</strong>指明了对象所在的主机；</li>
<li><strong>Connection</strong>指明服务器是否要在发送完被请求的对象后就关闭这条连接；</li>
<li><strong>User-agent</strong>指明用户代理，即向服务器发送请求的浏览器类型；</li>
<li><strong>Accept-language</strong>告知服务器用户代理能够处理的自然语言集。</li>
</ul>
<p>③在首部行后可能还有一个“实体体（entity body）”，只有当请求行的方法字段为POST时，实体体才会有内容。当使用POST时，表明用户在提交表单，最明显的就是使用搜索引擎进行搜索，此时用户提交的表单的值，也就是搜素值就在实体体中。</p>
<p>实际上在使用GET方法时，在URL中就是包括了输入的数据的。例如：</p>
<p>一个表单使用GET方法，它有两个字段，分别填写的是“monkeys”和“bananas”，那么URL的结构就为”<a target="_blank" rel="noopener" href="http://www.somesite.com/animalsearch?monkey&amp;bananas&quot;%EF%BC%88%E8%81%94%E6%83%B3%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB%E4%B8%AD%E6%89%80%E8%A7%81%E5%88%B0%E7%9A%84URL%EF%BC%89">www.somesite.com/animalsearch?monkey&amp;bananas&quot;（联想日常生活中所见到的URL）</a></p>
</li>
<li><p><strong>响应报文</strong>：由三个部分组成①初始<strong>状态行</strong>（与请求报文的初始行）②<strong>首部行</strong>③<strong>实体体</strong>（这是报文的主要部分，包含了所请求的对象本身），具体看看首部行：</p>
<p>①首部行包括但不限于：</p>
<ul>
<li><strong>Connection</strong>：与请求报文的Connection相同</li>
<li><strong>Date</strong>指明服务器产生并发送该响应报文的日期和时间，但要注意的是这个时间不是指对象创建或者最后修改的时间，而是服务器从它的文件系统中检索到该对象，将该对象插入响应报文，并发送该响应报文的时间</li>
<li><strong>Server</strong>：类似于请求报文中的User-agent</li>
<li><strong>Last-Modified</strong>：指示了对象创建或者最后修改的日期和时间</li>
<li><strong>Content-Length</strong>：指示了被发送对象中的字节数</li>
<li><strong>Content-Type</strong>：指示了实体体中的对象的文本类型例如HTML</li>
</ul>
<p>②状态行的状态码：状态码及其相应的短语指示了请求的结果。具体短语有：</p>
<ul>
<li><strong>200 OK</strong>：请求成功，信息在返回的响应报文中</li>
<li><strong>300 Moved Permanently</strong>：请求的对象已经被永久转移了，新的URL定义在响应报文的<strong>Location</strong>首部行中。客户软件将自动获取新的URL</li>
<li><strong>400 Bad Request</strong>：一个通用差错代码，指示该请求不能被服务器理解</li>
<li><strong>404 Not Found</strong>：被请求的文档不在服务器上</li>
<li><strong>505 HTTP Version Not Support</strong>：服务器不支持请求报文使用的HTTP协议版本</li>
</ul>
</li>
</ul>
</li>
<li><p>cookie：用户和服务器的交互。一个HTTP服务器是无状态的，但为了能够使Web站点识别用户（原因可能是：①服务器希望限制服务访问②服务器希望将内容与用户身份联系起来）cookie有四个组件：</p>
<ul>
<li>在HTTP响应报文中的一个cookie首部行</li>
<li>在HTTP请求报文中的一个cookie首部行</li>
<li>在用户端系统中保留有一个cookie文件，并由用户的浏览器进行管理</li>
<li>位于Web站点的一个后端数据库</li>
</ul>
<p>服务器可以通过cookie给用户设定的编码获取用户在Web站点的行为。</p>
</li>
<li><p>Web缓存：Web缓存器也叫<strong>代理服务器</strong>。它是能够代表初始Web服务器来满足HTTP请求的网络实体。Web缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。Web缓存器既是服务器也是客户——当浏览器向Web缓存器创建一个TCP连接并发送一个HTTP请求报文时，若Web缓存器中有对象副本，就发送HTTP响应报文，此时是一个服务器；若是没有，则继续向初始服务器发送HTTP请求报文，此时是客户。</p>
<p>部署Web缓存器的原因：</p>
<ul>
<li>可以大大减少对客户请求的响应时间</li>
<li>能够大大减少一个机构的接入链路到因特网的通信量</li>
<li>能够大大减低因特网上的Web流量</li>
</ul>
</li>
<li><p>电子邮件系统：有3个主要的组成部分——<strong>用户代理</strong>、<strong>邮件服务器</strong>、<strong>简单邮件传输协议</strong></p>
<p>主要用到的应用层协议是SMTP，与TCP一样，采用可靠数据传输服务，同时它也有两个部分：</p>
<ul>
<li>运行在发送方邮件服务器的客户端和运行在接收方邮件服务器的服务器端。</li>
</ul>
</li>
<li><p>关于SMTP：它是因特网电子邮件的核心，要注意的是它不通过中间邮件服务器发送邮件，即使这两个服务器相距再远，也是直接建立TCP连接。</p>
</li>
<li><p> HTTP与SMTP的对比：①都用于一台主机向另一台主机传送文件：HTTP是从Web服务器向Web客户端传送文件，SMTP是从一个邮件服务器向另一个邮件服务器传送文件；②当进行文件传输时，持续的HTTP与SMTP都是使用持续连接；③HTTP主要是一个<strong>拉协议</strong>，即在某时刻，用户是使用HTTP从一个Web服务器上拉取某些人在这个服务器上装载的信息。而SMTP是一个<strong>推协议</strong>，即发送邮件服务器把文件推向接收邮件服务器。前者的TCP连接是由想接受文件的机器发起的，后者的TCP连接是由要发送该文件的机器发起的。④SMTP要求每个报文才用7比特的ASCII码格式，而HTTP则没有这个要求；⑤HTTP是将每个对象封装到它自己的HTTP响应报文中，而SMTP则把所有报文对象放在一个报文中。</p>
</li>
<li><p>邮件报文格式：如同HTTP协议，每个首部行包含了可读文本——由关键词后跟冒号及其值组成。一些关键词是必须的，比如**From:<strong>，</strong>To:<strong>，</strong>Subject:**，另一些是必选的：</p>
</li>
<li><p>接收方是如何通过本地的用户代理去获取他的某ISP的邮件服务器上的邮件？</p>
<p>首先我们要知道的是接收方是无法通过SMTP来得到报文的，因为取报文是一个拉操作，SMTP是一个推协议，执行的推操作，所以就需要除了HTTP以外的新的、能够执行拉操作的协议：<strong>第三版的邮件协议（POP3）</strong>、<strong>因特网邮件访问协议（IMAP）</strong></p>
<ul>
<li><p>POP3</p>
<p>这是一个非常简单的协议，也就造成其功能相当有限。它按照三个阶段进行工作：特许、事务处理、更新。</p>
<ul>
<li><p>第一阶段，也即特许阶段，用户代理以明文的形式发送用户名和口令以鉴别用户。这一阶段主要有两个命令：user<user name>和pass <password>，</p>
</li>
<li><p>第二阶段，也即事务处理阶段，用户代理取回报文，同时用户代理还能对报文做删除标记、取消报文删除标记、获取邮件的统计信息的操作。这一阶段服务器会对用户的每个命令作出回答，一般是两种：+OK——被服务器用来指示前面的命令是正常的；-ERR——被服务器用来指示前面的命令出现某些差错。</p>
<p>这个阶段的具体过程被用户在用户代理中配置为了两种：下载并删除和下载并保留。</p>
<ul>
<li>使用下载并删除的方式：用户代理会发出list、retr、dele命令。用户代理首先请求邮件服务器列出所有存储的报文的长度，再从邮件服务器取回并删除每封邮件。</li>
<li>使用下载并保留的方式：这是为了解决下载并删除方式中客户不能使用不同的终端来进行邮件接收的问题。在下载并保留方式中，用户代理下载某邮件后，该邮件仍然保存在邮件服务器上，这样客户就能使用不同的终端重新读取这些邮件。</li>
</ul>
</li>
<li><p>第三阶段，也即更新阶段，它出现在客户发出quit命令后，目的是结束该POP3会话，这个时候该邮件服务器也要删除那些被标记为删除的报文。</p>
</li>
</ul>
<p>在POP3协议中，POP3服务器并不会在POP3会话过程中携带状态信息，也是因此大大简化了POP3服务的实现。</p>
</li>
<li><p>IMAP</p>
<p>是为了解决将报文存储在本地来移动麻烦的问题。在IMAP协议下，客户可以通过客户端直接对服务器上的邮件进行操作。它为客户提供了创建文件夹以及将邮件从一个文件夹移动到另一个文件夹的命令。同时还提供了在远程文件夹中查询邮件的命令。与POP3不同的是，IMAP服务器维护了IMAP绘画的用户状态信息。</p>
<p>此外，IMAP还允许用户代理仅仅去获取报文的一部分。</p>
</li>
<li><p>HTTP</p>
<p>使用HTTP进行电子邮件的收发时，用户代理就是普通的浏览器。使用基于Web的电子邮件时，要注意的是，从发送方到它的邮件服务器是通过HTTP建立的连接，而不是之前的SMTP.</p>
</li>
</ul>
</li>
<li><p>DNS：识别主机有两种方式——通过主机名或者IP地址。对于路由器而言，使用的是定长的、有着层次结构的IP地址；对于我们而言，则是喜欢使用主机名。为了能够在主机名和IP地址间建立一种映射关系，于是就有了<strong>域名系统（DNS）</strong></p>
<p>DNS是：①一个由分层的DNS服务器实现的<strong>分布式数据库</strong>，②一个使得主机能够查询分布式数据库的应用层协议。DNS服务器通常是运行在能够运行BIND的UNIX机器上的，并且DNS协议是运行在UDP上的，使用的是53号端口。</p>
<p>DNS通常是由其他应用层协议所使用（要注意，DNS只是个系统，而非协议），包括HTTP、SMTP、FTP等，就是为了将用户提供的主机名解析为IP地址。这是DNS系统提供的最主要的服务，此外它还提供服务有：</p>
<ul>
<li>主机别名：应用程序可以调用DNS来获得主机别名对应的规范主机名以及主机的IP地址</li>
<li>邮件服务器别名：同主机别名一样</li>
<li>负载分配：用于在冗余的服务器之间进行负载分配。繁忙的站点被冗余分布在多台服务器上，每台服务器均运行在不同的端系统上，每个都有着不同的IP地址，也就是说一个IP地址集合对应着同一个规范主机名</li>
</ul>
</li>
<li><p>关于DNS在互联网上的分布式数据库的实现：</p>
<ul>
<li><p><strong>分布式、层次数据库</strong>：DNS使用了大量的DNS服务器，并以层次方式组织分布在全世界范围内。这些服务器分为三类：<strong>根DNS服务器</strong>、<strong>顶级域（TLD）DNS服务器</strong>、<strong>权威DNS服务器</strong>。在《自顶而下》中，以<a href="http://www.amazon.com为例，DNS解析它的过程被分为：">www.amazon.com为例，DNS解析它的过程被分为：</a></p>
<p>①客户先与根服务器之一联系，将返回顶级域名com的TLD服务器的IP地址</p>
<p>②根据返回的IP地址，与对应的TLD服务器中的一个联系，它将为amazon.com返回权威服务器的IP地址</p>
<p>③最后于amazon.com的权威服务器之一联系，它为主机名<a target="_blank" rel="noopener" href="http://www.amazon.com返回其ip地址/">www.amazon.com返回其IP地址</a></p>
<ul>
<li>根DNS服务器：DNS中最高级别的域名服务器，返回的是TLD服务器的IP地址。</li>
<li>顶级域（TLD）DNS服务器：对每个通用顶级域（例如com、org、net、edu和gov）和所有国家及地区顶级域（例如uk、fr、ca和jp），都有TLD服务器或服务器集群。返回的是权威DNS服务器的IP地址。</li>
<li>权威DNS服务器：多数大学和大公司实现和维护它们自己基本和辅助（备份）的权威DNS服务器。一个组织的权威DNS服务器收藏的是，在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的DNS记录，这些记录会将这些主机的名字映射为IP地址。</li>
</ul>
<p>要注意，DNS对域名进行解析，是从外到内的逐层进行解析。还是以<a target="_blank" rel="noopener" href="http://www.amazon.com为例,先在根域名服务器解析com,再在tld服务器解析amazon.com,最后在权威服务器中解析www.amazon.com.在这个解析过程中,一共有6份报文——3份查询报文和3份回答报文./">www.amazon.com为例，先在根域名服务器解析com，再在TLD服务器解析amazon.com，最后在权威服务器中解析www.amazon.com。在这个解析过程中，一共有6份报文——3份查询报文和3份回答报文。</a></p>
<p>3份查询报文分别是请求主机向根DNS服务器、向TLD DNS服务器、向权威DNS服务器发出的查询报文</p>
<p>3份回答报文分别是根DNS服务器、TLD DNS服务器、权威DNS服务器分别向请求主机发出的回答报文</p>
<p>还有一种服务器是<strong>本地DNS服务器（也叫默认名字服务器）</strong>，但严格来说它并不属于DNS的层次结构。每个ISP都有一个本地DNS服务器。每一次请求主机向外发送查询报文时，都是先向本地DNS服务器发送查询报文，并由本地DNS服务器发送/接收其他三种DNS服务器的报文。</p>
<p>所以说上面那个例子实际上是8份报文——4份查询报文和4份回答报文。多的是请求主机与本地DNS服务器间的报文发送和接受。</p>
</li>
<li><p><strong>查询方式</strong>：<strong>递归查询</strong>和<strong>迭代查询</strong>——从请求主机到本地DNS服务器的查询是递归查询，其余的查询时迭代查询。</p>
</li>
<li><p><strong>DNS缓存：</strong>为了改善时延性能并减少在因特网上到处传输的DNS报文数量，DNS广泛使用了缓存技术。其原理为：在一个请求链中，当某DNS服务器接收一个DNS回答时，它能将映射缓存在本地存储器中。</p>
<p>这样做的好处就是在一段时间内能够为其他主机提供所要求的IP地址，即使它不是该主机的权威服务器。但要注意的是，是在一段时间内，DNS服务器会在一段时间后（通常时设置的两天）丢弃缓存的信息。</p>
</li>
</ul>
</li>
<li><p>为什么DNS是基于UDP而不是TCP?</p>
<p>衡量计算机通信快慢的指标是“响应时间”，即从用户发出通信指令开始，到用户看完完整页面为止所流逝的时间。</p>
<p>以浏览器为例，响应时间分为三部分：响应时间 = DNS域名解析时间 + TCP连接时间 + HTTP交易时间</p>
<p>TCP连接时间时固定的三次握手时间；HTTP交易时间是基于Request/Response，很难有提升时间；所以网络工程师就将时间上的优化放在了DNS的域名解析上。</p>
<p>①若DNS基于TCP，那么解析时间公式就为：</p>
<p>DNS域名解析时间 = TCP连接时间 + DNS交易时间</p>
<p>②若DNS基于UDP，那么解析时间公式就为：</p>
<p>DNS域名解析时间 = DNS交易时间</p>
<p>从表达式上就能看出基于UDP能够节约一定的连接时间，毕竟UDP是面向无连接的。</p>
</li>
<li><p>DNS记录：共同实现DNS分布式数据库的所有DNS服务器存储了<strong>资源记录（RR）</strong>,它提供了主机到IP地址的映射。资源记录是一个包含了如下字段的4元组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Name, Value, Type, TTL)</span><br></pre></td></tr></table></figure>

<p>Type一共有四种取值：</p>
<ul>
<li>Type = A：表示Value是名为Name的主机的IP地址。这个记录提供了标准的主机名到IP地址的映射。</li>
<li>Type = NS：表明Name是一个域，而Value是一个知道如何获得该域中主机IP地址的权威DNS服务器的主机名。这个记录用来沿着查询链来路由DNS查询。</li>
<li>Type = CNAME：表明Value是别名为Name的主机对应的规范主机名。这个记录能够向查询的主机提供一个主机名对应的规范主机名。</li>
<li>Type = MX：表明Value是个别名为Name的邮件服务器的规范主机名。这只是获得邮件服务器的别名。</li>
</ul>
</li>
<li><p>DNS报文具体格式：DNS两种报文报文有着相同的格式。</p>
<ul>
<li><strong>前12个字节是首部区域</strong>：第一个字段是<strong>标识符</strong>，占16比特的数，用于标识该查询，这个标识符会被复制到对该查询的回答报文中；第二字段是<strong>标志</strong>，占1比特的数，用于指明该报文是查询报文（0）还是回答报文（1）；第三字段是<strong>问题数</strong>；第四字段是<strong>回答RR数</strong>；第五字段是<strong>权威RR数</strong>；第六字段是<strong>附加RR数</strong></li>
<li><strong>问题区域</strong>：包含正在进行的查询信息，包括：①名字字段，包含正在被查询的主机；②类型字段，指出有关该名字的正在被询问的问题类型</li>
<li><strong>回答区域</strong>：包含了对最初请求的名字的资源记录。在回答报文的回答区域中可以包含多条RR，因此一个主机名能够有多个IP地址</li>
<li><strong>权威区域</strong>：包含了其他权威服务器的记录</li>
<li><strong>附加区域</strong>：包含的是其他有帮助的记录</li>
</ul>
</li>
<li><p>P2P：能够实现从单一服务器向大量主机（称为对等方）分发一个大文件。在《自顶而下》中，通过假定在一个小时内一个对等方能够传输整个文件，并且该服务器的传输速率是对等方上载速率的10倍，以及对等方的下载速率被设置得足够大，就发现：</p>
<p>①对于客户-服务器体系结构，随着对等方数量的增加，发布时间呈线性增长并没有界</p>
<p>②对于P2P体系结构，最小分发时间不仅总是小于客户-服务器体系结构的分发时间，并且对于任意的对等方数量N，总是小于1小时</p>
<p>所以说，具有P2P体系结构的应用程序能够是自扩展的。这种扩展性的直接成因是对等方除了是比特的消费者外还是他们的重新分发者。</p>
</li>
<li><p> 对流式视频最重要的性能度量是<strong>平均端到端吞吐量</strong>。通常压缩的因特网视频的比特率范围通常从用于低质量视频的100kbps到用于流式高分辨率电影的超过3Mbps。所以为了提供连续不断的布局，网络必须为流式应用提供平均吞吐量，这个流式应用至少与压缩视频的比特率一样大。</p>
</li>
<li><p>CDN（内容分发网）：为了应对向分布于全世界的用户分发巨量视频数据而提出的网络。CDN通常采用两种不同的服务器安置原则：</p>
<ul>
<li><strong>深入</strong>：通过在遍及全球的接入ISP中部署服务器集群来<strong>深入</strong>到ISP的接入网中。其目标是靠近端用户，通过减少端用户和CDN集群之间链路和路由器的数量，从而改善用户感受的时延和吞吐量。</li>
<li><strong>邀请做客</strong>：通过在少量关键位置建造大量集群来<strong>邀请</strong>到ISP中做客。不是将集群放在接入ISP中，这些CDN通常将它们集群放置在因特网交换点（IXP）。</li>
</ul>
<p>两者的比较：前者的高度分布式设计，给维护和管理集群的任务带来了极大的挑战；后者通常产生较低的维护和管理开销，代价就是对端用户的较高时延和较低吞吐量。</p>
</li>
<li><p> CDN是怎么工作的：<strong>理论上</strong>，一旦CDN的集群准备就绪，它就可以跨集群复制内容，同时CDN也不会将每个视频的副本放置在每个集群中。<strong>但实际上</strong>，许多CDN并没有将视频推入它们的集群，而是使用一种简单的<strong>拉策略</strong>：如果客户向一个未存储该视频的集群请求某视频，则该集群检索该视频（从某中心仓库或者从另一个集群），向客户流式传输视频时的同时在本地存储一个副本。这很类似于因特网缓存，当某集群存储器变满时，它删除不经常请求的视频。</p>
</li>
<li><p> CDN部署的核心是<strong>集群选择策略</strong>，即动态地将客户定向到CDN中的某个服务器集群或数据中心的机制。</p>
</li>
<li><p>开发者创建一个网络应用时，其主要任务就是编写客户程序和服务器程序的代码。这就是套接字编程。</p>
<ul>
<li><p>UDP套接字编程</p>
<p>在发送进程能够将数据分组推出套接字之门之前，当使用UDP时，必须先将目的地址附在该分组上面。在该分组传过发送方的套接字之后，因特网将使用该目的地址通过因特网为该分组选路到接收进程的套接字。当分组到达接受套接字时，接收进程将通过该套接字取回分组，然后检查分组的内容并采取适当的动作。</p>
<p>对于这个附着在分组上的目的地址，它包括了目的主机的IP地址、目的地套接字的端口号。</p>
<p>这里介绍C++中的socket函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></span><br></pre></td></tr></table></figure>

<p>函数的使用要用的头文件有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数domain：表示要使用的协议簇，协议簇定义在第二个头文件中，包括了：</p>
<table>
<thead>
<tr>
<th align="center">AF_INET</th>
<th align="center">IPv4网络通信</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>AF_INET6</strong></td>
<td align="center"><strong>IPv6网络通信</strong></td>
</tr>
<tr>
<td align="center"><strong>AF_PACKET</strong></td>
<td align="center"><strong>链路层通信</strong></td>
</tr>
<tr>
<td align="center"><strong>AF_UNIX, AF_LOCAL</strong></td>
<td align="center"><strong>本地通信</strong></td>
</tr>
</tbody></table>
</li>
<li><p>参数type：表示套接字的类型，包括了：</p>
<table>
<thead>
<tr>
<th align="center">SOCK_STREAM</th>
<th align="center">TCP字节流套接字</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>SOCK_DGRAM</strong></td>
<td align="center"><strong>UDP数据报套接字</strong></td>
</tr>
<tr>
<td align="center"><strong>SOCK_RAW</strong></td>
<td align="center"><strong>原始套接字</strong></td>
</tr>
<tr>
<td align="center"><strong>SOCK_SEQPACKET</strong></td>
<td align="center"><strong>有序分组套接字</strong></td>
</tr>
</tbody></table>
</li>
<li><p>参数protocol：选择传输协议的类型</p>
<table>
<thead>
<tr>
<th align="center">IPPROTO_TCP</th>
<th align="center">TCP传输协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>IPPTOTO_UDP</strong></td>
<td align="center"><strong>UDP传输协议</strong></td>
</tr>
<tr>
<td align="center"><strong>IPPTOTO_SCTP</strong></td>
<td align="center"><strong>STCP传输协议</strong></td>
</tr>
<tr>
<td align="center"><strong>IPPTOTO_TIPCTCP</strong></td>
<td align="center"><strong>TIPC传输协议</strong></td>
</tr>
</tbody></table>
</li>
<li><p><strong>客户端：</strong></p>
<p>①创建套接字描述符（使用socket()方法）</p>
<p>②设置服务器的IP地址和端口号（使用htons()方法，转换为网络字节序的格式）</p>
<p>③向套接字描述符写入请求并发送给服务器（使用sendto()方法）</p>
<p>④从套接字描述符读取来自服务器的应答（使用recvfrom()方法）</p>
<p>⑤关闭套接字描述符（使用close()方法）</p>
</li>
<li><p><strong>服务端：</strong></p>
<p>①创建套接字描述符（使用socket()方法）</p>
<p>②设置服务器的IP地址和端口号（使用htons()方法，转换为网络字节序的格式）</p>
<p>③将套接字描述符绑定到服务器地址（使用bind()方法）</p>
<p>④从套接字描述符读取来自客户端的请求并取得客户端的地址（使用recvfrom()方法）<br>⑤向套接字描述符写入应答并发送给客户端（使用sendto()方法）<br>⑥回到第4步等待读取下一个来自客户端的请求</p>
</li>
</ul>
<p>客户端和服务端的代码示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、UDPClient.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span><span class="comment">// WINSOCK API的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WS2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)<span class="comment">// WINSOCK API连接库文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无论是UDP还是TCP，在进行套接字描述符的创建前，都要先进行winsock库的连接</span></span><br><span class="line">    WORD socketVersion = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);<span class="comment">// 调用Winsock2.2版本</span></span><br><span class="line">	WSADATA wsaData;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(socketVersion, &amp;wsaData) != <span class="number">0</span>)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;WSAStartup failed:&quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;<span class="comment">// 加载套接字库</span></span><br><span class="line"></span><br><span class="line">	SOCKET sclient = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP); <span class="comment">//客户端套接字</span></span><br><span class="line"></span><br><span class="line">	sockaddr_in sin;</span><br><span class="line">	sin.sin_family = AF_INET;</span><br><span class="line">	sin.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);</span><br><span class="line">	<span class="comment">/*sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);*/</span></span><br><span class="line">	<span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, (<span class="keyword">void</span>*)&amp;sin.sin_addr.S_un.S_addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(sin);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* sendData = <span class="string">&quot;来自客户端的数据包.\n&quot;</span>;</span><br><span class="line">	<span class="built_in">sendto</span>(sclient, sendData, <span class="built_in">strlen</span>(sendData), <span class="number">0</span>, (sockaddr*)&amp;sin, len);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> recvData[<span class="number">255</span>];</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="built_in">recvfrom</span>(sclient, recvData, <span class="number">255</span>, <span class="number">0</span>, (sockaddr*)&amp;sin, &amp;len);</span><br><span class="line">	<span class="keyword">if</span> (ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		recvData[ret] = <span class="number">0x00</span>;</span><br><span class="line">		<span class="built_in">printf</span>(recvData);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">closesocket</span>(sclient);</span><br><span class="line">	<span class="built_in">WSACleanup</span>();<span class="comment">//这两句话就是关闭socket连接</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// UDPServer.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WS2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)    </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	WSADATA wsaData;</span><br><span class="line">	WORD sockVersion = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(sockVersion, &amp;wsaData) != <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SOCKET serSocket = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP); <span class="comment">//服务端套接字</span></span><br><span class="line">	<span class="keyword">if</span> (serSocket == INVALID_SOCKET)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;socket error !&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sockaddr_in serAddr;</span><br><span class="line">	serAddr.sin_family = AF_INET;</span><br><span class="line">	serAddr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);</span><br><span class="line">	serAddr.sin_addr.S_un.S_addr = INADDR_ANY;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">bind</span>(serSocket, (sockaddr*)&amp;serAddr, <span class="built_in"><span class="keyword">sizeof</span></span>(serAddr)) == SOCKET_ERROR)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bind error !&quot;</span>);</span><br><span class="line">		<span class="built_in">closesocket</span>(serSocket);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sockaddr_in remoteAddr;</span><br><span class="line">	<span class="keyword">int</span> nAddrLen = <span class="built_in"><span class="keyword">sizeof</span></span>(remoteAddr);</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="keyword">char</span> recvData[<span class="number">255</span>];</span><br><span class="line">		<span class="keyword">int</span> ret = <span class="built_in">recvfrom</span>(serSocket, recvData, <span class="number">255</span>, <span class="number">0</span>, (sockaddr*)&amp;remoteAddr, &amp;nAddrLen);</span><br><span class="line">		<span class="keyword">if</span> (ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			recvData[ret] = <span class="number">0x00</span>;</span><br><span class="line">			<span class="keyword">char</span> sendBuf[<span class="number">20</span>] = &#123; <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;接受到一个连接：%s \r\n&quot;</span>, <span class="built_in">inet_ntop</span>(AF_INET, (<span class="keyword">void</span>*)&amp;remoteAddr.sin_addr, sendBuf, <span class="number">16</span>));</span><br><span class="line">			<span class="built_in">printf</span>(recvData);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span>* sendData = <span class="string">&quot;UDP测试\n&quot;</span>;</span><br><span class="line">		<span class="built_in">sendto</span>(serSocket, sendData, <span class="built_in">strlen</span>(sendData), <span class="number">0</span>, (sockaddr*)&amp;remoteAddr, nAddrLen);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">closesocket</span>(serSocket);</span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>TCP套接字编程</p>
<p>TCP编程与UDP最大的不同就是客户与服务器之间要先进行握手和创建一个连接。同时与UDP一样，TCP服务器在客户试图发起接触之前必须作为一个进程运行起来。</p>
<p>随着服务器进程的运行，客户进程能够向服务器发起一个TCP连接。这是由客户程序通过创建一个TCP套接字完成的。当客户生成其TCP套接字时，它指定了服务器中的欢迎套接字的地址，即服务器主机的IP地址及其套接字的端口号。生成套接字后，该客户发起了一个三次握手并创建与服务器的一个TCP连接。发生在运输层的三次握手，对于客户和服务器是完全透明的。</p>
<p>从应用程序的观点来看，客户套接字和服务器连接套接字直接通过一根管道连接，客户进程能够向它的套接字发送任意字节，并且TCP保证服务器进程能够按发送的顺序接收每个字节。</p>
<p>具体编程为：</p>
<ul>
<li><p><strong>客户端</strong></p>
<p>①创建套接字描述符（使用socket()方法）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOCKET sclient = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br></pre></td></tr></table></figure>

<p>②设置服务器的IP地址和端口号（需要转换为网络字节序的格式）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in sin;</span><br><span class="line">sin.sin_family = AF_INET;</span><br><span class="line">sin.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">// 设置端口号，转换为网络字节序的格式</span></span><br><span class="line"><span class="comment">/*sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);*/</span></span><br><span class="line"><span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, (<span class="keyword">void</span>*)&amp;sin.sin_addr.S_un.S_addr);<span class="comment">// 设置IP地址</span></span><br></pre></td></tr></table></figure>

<p>③请求建立到服务器的TCP连接并阻塞，直到连接成功建立（使用connect()方法）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">connect</span>(sclient, (sockaddr *)&amp;serAddr, <span class="built_in"><span class="keyword">sizeof</span></span>(serAddr)) == SOCKET_ERROR)&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;connect error !&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">closesocket</span>(sclient);<span class="comment">// 如果连接失败，就关闭套接字</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>④向套接字描述符写入请求（使用send()函数）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;输入你想传输的数据： \n&quot;</span>;</span><br><span class="line">string data;</span><br><span class="line">cin &gt;&gt; data;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * sendData2;</span><br><span class="line">sendData2 = data.<span class="built_in">c_str</span>(); <span class="comment">//string转const char*</span></span><br><span class="line"><span class="built_in">send</span>(sclient, sendData2, <span class="built_in">strlen</span>(sendData2), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>⑤从套接字描述符读取来自服务器的应答（使用revc()函数）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> recData[<span class="number">255</span>];</span><br><span class="line"><span class="keyword">int</span> ret = <span class="built_in">recv</span>(sclient, recData, <span class="number">255</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">	recData[ret] = <span class="number">0x00</span>;</span><br><span class="line">	<span class="built_in">printf</span>(recData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑥关闭套接字描述符（使用close()方法）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">closesocket</span>(sclient);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>服务端</strong></p>
<p>①创建套接字描述符（使用socket()方法）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SOCKET slisten = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br></pre></td></tr></table></figure>

<p>②设置服务器的IP地址和端口号（需要转换为网络字节序的格式）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in sin;</span><br><span class="line">sin.sin_family = AF_INET;</span><br><span class="line">sin.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);<span class="comment">// 设置端口号，转换为网络字节序的格式</span></span><br><span class="line">sin.sin_addr.S_un.S_addr = INADDR_ANY; <span class="comment">//监听任意的地址</span></span><br></pre></td></tr></table></figure>

<p>③将套接字描述符绑定到服务器地址（使用bind()方法）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">bind</span>(slisten, (LPSOCKADDR)&amp;sin, <span class="built_in"><span class="keyword">sizeof</span></span>(sin)) == SOCKET_ERROR)&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;bind error !&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>④将套接字描述符设置为监听套接字描述符（使用listen()方法），等待来自客户端的连接请求，监听套接字维护未完成连接队列和已完成连接队列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">listen</span>(slisten, <span class="number">5</span>) == SOCKET_ERROR)&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;listen error !&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑤从已完成连接队列中取得队首项，返回新的已连接套接字描述符（使用accept()方法），如果已完成连接队列为空，则会阻塞</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环接受数据</span></span><br><span class="line">SOCKET sClient;  <span class="comment">//创建连接的套接字</span></span><br><span class="line">sockaddr_in remoteAddr;</span><br><span class="line"><span class="keyword">int</span> nAddrlen = <span class="built_in"><span class="keyword">sizeof</span></span>(remoteAddr); <span class="comment">//用于接受客户端地址</span></span><br><span class="line"><span class="keyword">char</span> revData[<span class="number">255</span>]; <span class="comment">//存储接受的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;等待连接...\n&quot;</span>;</span><br><span class="line">	sClient = <span class="built_in">accept</span>(slisten, (SOCKADDR *)&amp;remoteAddr, &amp;nAddrlen); <span class="comment">//和客户端所使用的connect()方法对应</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑥从已连接套接字描述符读取来自客户端的请求（使用recv()方法）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = <span class="built_in">recv</span>(sClient, revData, <span class="number">255</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">	revData[ret] = <span class="number">0x00</span>;</span><br><span class="line">	<span class="built_in">printf</span>(revData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑦向已连接套接字描述符写入应答（使用send()方法）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *sendData = <span class="string">&quot;你好，TCP客户端！ \n&quot;</span>;</span><br><span class="line"><span class="built_in">send</span>(sClient, sendData, <span class="built_in">strlen</span>(sendData), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>⑧关闭已连接套接字描述符（使用close()方法）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">closesocket</span>(sClient);</span><br></pre></td></tr></table></figure>

<p>⑨最后关闭监听的套接字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">closesocket</span>(slisten);</span><br></pre></td></tr></table></figure></li>
<li><p>关于服务器和客户端编程的异同：</p>
<p>相同点：首先都要通过**socket()<strong>创建套接字描述符，并设置服务器的IP地址和端口号，端口号都要通过</strong>htons()**转换为网络字节序的格式，最后都要及时关闭所有开启的套接字描述符。</p>
<p>差异点：客户端是先发起请求，再接收来自服务器的应答，所以是先使用**send()<strong>，再使用</strong>recv()<strong>；而服务器则是先接受来自客户端的请求，在做出应答，所以是先使用</strong>recv()<strong>，再使用</strong>send()**。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>关于在UDP与TCP编程中经常使用的几种函数：</p>
<ul>
<li><p><strong>socket()函数</strong></p>
</li>
<li><p><strong>send()函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(SOCKET s, <span class="keyword">const</span> <span class="keyword">char</span> FAR *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span></span><br></pre></td></tr></table></figure>

<p>无论是客户还是服务器应用程序，都是使用send()函数来向TCP连接的另一端发送数据。注意几个关键词：TCP连接，发送。</p>
<p>①第一个参数指定了套接字描述符</p>
<p>②第二个参数指明一个存放应用程序要发送数据的缓冲区</p>
<p>③第三个参数指明实际要发送的数据的字节数</p>
<p>④第四个参数一般置为0</p>
</li>
<li><p><strong>recv函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(SOCKET s, <span class="keyword">const</span> <span class="keyword">char</span> FAR *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span></span><br></pre></td></tr></table></figure>

<p>无论是客户还是服务器应用程序，都是使用recv()函数来向TCP连接的另一端接收数据。注意几个关键词：TCP连接，接收。</p>
<p>①第一个参数指定接收端套接字描述符；</p>
<p>②第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；</p>
<p>③第三个参数指明buf的长度；</p>
<p>④第四个参数一般置0。</p>
</li>
</ul>
</li>
</ul>
<h1 id="第三章-运输层"><a href="#第三章-运输层" class="headerlink" title="第三章 运输层"></a>第三章 运输层</h1><ul>
<li><p>运输层协议为运行在不同主机上的应用进程之间提供了<strong>逻辑通信</strong>功能</p>
</li>
<li><p>将主机间交付扩展到进程间交付被称为运输层的<strong>多路复用</strong>和<strong>多路分解</strong></p>
<ul>
<li>将运输层报文段中的数据交付到正确的套接字的工作被称为<strong>多路分解</strong></li>
<li>在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，所有这些工作被称为<strong>多路复用</strong></li>
</ul>
</li>
<li><p>多路复用的要求：①套接字有唯一标识符②每个报文段有特殊字段来指示该报文段所要交付到的套接字。这些特殊字段是<strong>源端口号字段</strong>和<strong>目的端口号字段</strong>。</p>
</li>
<li><p>运输层是怎样实现分解服务的？</p>
<p>在主机上的每个套接字能够分配一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字，然后报文段中的数据通过套接字进入其所连接的进程。</p>
</li>
<li><p>无连接的多路复用和多路分解：</p>
<p>在UDP编程中，通过使用socket()函数能够创建起一个套接字描述符。但当通过这种方法创建UDP套接字时，运输层是自动为这个套接字分配一个端口，范围是1024~65535。也可以通过bind()方法，为这个UDP套接字指定一个端口。</p>
<p>一个UDP套接字是由一个二元组全面标识的：它包含一个目的IP地址和一个目的端口号</p>
<p>对于UDP而言，如果两个UDP报文段有不同的源IP地址和/或源端口号，但是具有相同的目的IP地址和目的端口号，那么它们俩将通过相同的目的套接字被定向到相同的目的进程。</p>
</li>
<li><p>面向连接的多路复用和多路分解;</p>
<p>一个TCP套接字是由一个四元组全面标识的：它包含源IP地址、源端口号、目的IP地址、目的端口号</p>
<p>与UDP不同的是，两个具有不同源IP地址或源端口号的TCP报文段将被定向到两个不同的套接字，除非它们俩携带了初始创建连接的请求。</p>
</li>
<li><p>具体研究研究<strong>无连接运输：UDP</strong></p>
<p>对于任何一种协议，都要考虑到运输层最低限度必须提供一种复用/分解服务，以便在网络层与正确的应用级进程之间传递数据。</p>
<p>UDP就只是做了运输协议能够做的最少工作。除了复用/分解功能及少量的差错检测外，它几乎没有对IP增加别的东西。也就是说，如果开发人员选择了UDP，那么这个应用程序差不多就是直接与IP打交道。</p>
<p>那么什么时候选用UDP？</p>
<ul>
<li><p><strong>关于发送什么数据以及何时发送的应用层控制更为精细</strong></p>
<p>由于TCP有一个拥塞控制机制，这就导致当源和目的主机间的一条或多条链路变得极度拥塞时，运输层TCP发送方就会被遏制。但之后TCP仍将继续重新发送数据报文段直到目的主机收到此报文段并加以确认。它是不管可靠交付需要多长时间的。</p>
<p><strong>但</strong>实时应用通常要求最小的发送速率，不希望过分的延迟报文段的发送，并且能够容忍一些数据的丢失，基于这些的应用程序就可以使用UDP</p>
</li>
<li><p><strong>无须连接建立</strong></p>
<p>UDP并不需要像TCP那样在开始传输数据之前要进行三次握手，它无需任何准备就能够进行数据传输。所以UDP就没有建立连接的时延。</p>
</li>
<li><p><strong>无连接状态</strong></p>
<p>这个连接状态包括接收和发送缓存、拥塞控制参数、序号与确认号的参数。TCP是需要在端系统中维护连接状态的以实现它的拥塞控制机制。而UDP不维护连接状态，也不跟踪这些参数。所以对那些专门用于某种特定应用的服务器当应用程序运行在UDP上时，能够支持更多的活跃用户。</p>
</li>
<li><p><strong>分组首部开销小</strong></p>
<p>对于TCP报文段20字节的首部开销，UDP仅有8字节。</p>
</li>
</ul>
</li>
<li><p>UDP报文段结构：</p>
<p>应用层数据占用UDP报文段的数据字段，数据字段要么包含一个查询报文，要么包含一个响应报文。</p>
<p>UDP首部只有4个字段，每个字段由两个字节组成。4个字段分别为：源端口号、目的端口号、长度、检验和</p>
<p>通过两个端口号能够使目的主机将应用数据交给运行在目的端系统中的相应进程。（这里就是执行分解功能）</p>
<p>长度字段指示了在UDP报文段中的字节数。</p>
<p>接收方使用检验和来检查该报文段中是否出现了差错。</p>
</li>
<li><p>UDP检验和：提供了差错检测功能，也就是：检验和用于确定当UDP报文段从源到达目的地移动时，其中的比特是否发生了变化。</p>
<p>但要注意的是，UDP只提供了差错检测，它并不提供差错恢复的能力。</p>
</li>
<li><p>可靠数据传输（rdt）原理：</p>
<ul>
<li><p><strong>rdt1.0</strong>：经完全可靠信道的可靠数据传输</p>
<p>这是最简单的一种情况，底层信道是完全可靠的。</p>
<p>rdt的发送端只通过rdt_send(data)事件接受来自较高层的数据，产生一个包含该数据的分组（经由make_pkt(data)动作），并将数据上传给较高层（通过deliver_data(data)动作）。而rdt_rcv(packet)事件是由较低层协议的过程调用生产的。</p>
<p>在这个简单的协议中，一个单元数据与一个分组是没有差别的。而且所有分组是发送方流向接收方；有了完全可靠的信道，接收方就不需要提供任何反馈信息给发送方。</p>
</li>
<li><p><strong>rdt2.0</strong>：经具有比特差错信道的可靠数据传输</p>
<p>在计算机网络环境中，基于<strong>肯定确认</strong>和<strong>否定确认</strong>这样的重传机制的可靠数据传输协议被称为<strong>自动重传请求（ARQ）</strong>协议</p>
<p>为处理比特差错，ARQ协议还需要另外三种协议功能：</p>
<p>①<strong>差错检测</strong>：带有差错检测的比特将会被汇集到rdt2.0数据分组的分组检验和字段中。</p>
<p>②<strong>接收方反馈</strong>：rdt2.0协议将从接收方向发送方回送ACK与NAK分组。理论上这些分组只需要一个比特——用0表示NAK，用1表示ACK。</p>
<p>③<strong>重传</strong>：接收方收到有差错的分组时，发送方将重传该分组文。</p>
<p>具体的发送过程就为：初始状态发送端协议等待来自上层传下来的数据。当rdt_send(data)事件出现是，发送方将产生一个带有检验和的、包含待发送数据的分组（sndpkt = make_pkt(data, checksum)），然后经由udt_send(sndpkt)操作发送该分组。发送端执行完上述的操作后，发送端就开始等待来自接收端的ACK分组或NAK分组。如果收到一个ACK分组（rdt_rcv(rcvpkt) &amp;&amp; isACK(rcvpkt)），就意味着协议将会返回到等待来自上层的数据的状态。如果收一个NAK分组，就重传上一个分组（udt_send(sndpkt)）。</p>
<p>在这个过程中，当发送方处于等到接收ACK或NAK分组时，它是不会再接收来自上层的数据，也就是udt_send(next_sndpkt)事件不会出现。</p>
<p>rdt2.0有一个致命的缺陷：ACK或NAK分组可能受损。如果一个ACK或NAK分组受损，发送方无法知道接收方是否正确接受了上一块发送的数据。</p>
<p>《自顶而下》中考虑了处理受损ACK和NAK时的3种可能性：</p>
<ul>
<li>在协议中引入一种新型发送方到接收方的分组，接收方则将复述其回答。</li>
<li>增加足够的检验和比特，以使发送方检测差错和恢复差错。</li>
<li>当发送方收到含糊不清的ACK或NAK分组时，只需要重传当前数据分组。这种方法是在发送方到接收方的信道中引入<strong>冗余分组</strong>。冗余分组的根本困难在于接收方不知道它上次所发送的ACK或NAK是否被发送方正确地收到。因为它不知道接收到的分组是新的还是一次重传的。</li>
</ul>
<p>解决这些问题的方法是在数据分组中添加一个新字段，让发送方对其数据分组编号，即将发送数据分组的<strong>序号</strong>放在该字段。于是就有了rdt2.0的一系列修订版</p>
<p><strong>rdt2.1</strong>：</p>
<p>发送方和接收方的FSM的状态数都是之前版本的两倍。因为在修订后的协议中，要求协议状态此时必须反映出目前正发送的分组或希望接收的分组的序号是0还是1。它使用了从接收方到发送方的肯定确认和否定确认。</p>
<p><strong>rdt2.2</strong>：</p>
<p>是在比特差错信道上实现的一个无NAK的可靠数据传输协议。与2.1相比，接收方此时必须包括由一个ACK报文所确认的分组序号（可以通过在接收方FSM中，在make_pkt()中包括参数ACK 0或ACK 1来实现），发送方此时必须检查接收到的ACK报文中被确认的分组序号（可以通过在发送方FSM中，在isACK()中包括参数0或1来实现）</p>
</li>
<li><p><strong>rdt3.0</strong>：经具有比特差错的丢包信道的可靠数据传输（也被特定称为<strong>比特交替协议</strong>）</p>
<p>3.0主要是解决怎样检测丢包和发生丢包后应该做什么。</p>
<p>丢包的标准是什么？在实践中采取的方法是发送方明智地选择一个时间值，以判断可能发生了丢包。</p>
<p>如果在这个时间内没有收到ACK，则重传该分组。为了实现基于时间的重传机制，需要一个<strong>倒计数定时器</strong>，在一个给定的时间量过期后，可中断发送方。所以，发送方需要做的是：①每次发送一个分组（包括第一次分组和重传分组）时，便启动一个定时器；②响应定时器中断；③终止定时器</p>
</li>
</ul>
</li>
<li><p>rdt3.0依然有它不足之处：它是一个停等协议。这也就意味着rdt3.0有着非常低的发送方利用率。为解决这个问题，就有了新的可靠数据传输协议：流水线可靠数据传输协议。</p>
<p>①增加序号的范围，因为每个输送中的分组必须有一个唯一的序号，而且也许有多个在输送中的未确认报文，而且也许有多个在输送中的未确认报文。</p>
<p>②协议的发送方和接收方两端需要缓存多个分组。发送方最低限度应当能缓冲那些已发送但没有确认的分组。</p>
<p>③所需的序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏以及延时过大的分组。</p>
<p>解决流水线的差错恢复的两种基本方法是：①<strong>回退N步（GBN）</strong>②<strong>选择重传（SR）</strong></p>
<ul>
<li><p><strong>回退N步（GBN）</strong>——或被称为<strong>滑动窗口协议</strong></p>
<p>在<strong>回退N步（GBN）协议</strong>中，允许发送方发送多个分组而不需要等待确认，但也受限于在流水线中未确认的分组数不能超过某个最大允许数N。</p>
<p>在GBN协议中，发送方看到的序号被分为四个部分：<strong>已被确认的序号</strong>、<strong>发送但还未确认的序号</strong>、<strong>可用但还未发送的序号</strong>、<strong>不可用的序号</strong>。</p>
<p>将<strong>发送但还未确认的序号</strong>的第一个序号定义为<strong>基序号（base）</strong>，将<strong>可用但还未发送的序号</strong>的第一个序号定义为**下一个序号(nextseqnum)**，这两个部分的序号长度我们设为N，也就是窗口的长度。但这个N的大小是会被限制的。</p>
<p>GBN发送方必须响应三种类型的事件：</p>
<ul>
<li><strong>上层的调用</strong>：当上层调用rdt_send()时，发送方首先检查发送窗口是否已满，，即是否有N个已发送但未被确认的分组。如果窗口未满，则产生一个分组并发送，同时更新相应的变量；如果窗口已满，发送方只需将数据返回给上层，隐式地指示上层该窗口已满。这里似乎是通过一个判断语句来实现，但在实际实现中，发送方更可能缓存这些数据，而不是立刻发送，或者使用同步机制允许上层在仅当窗口不满时才调用rdt_send()。</li>
<li><strong>收到一个ACK</strong>：在GBN协议中，对序号为n地分组采用的确认方式是<strong>累计确认</strong>的方式，来表明接收方已正确的接收到序号为n的之前的所有分组（包括n）</li>
<li><strong>超时事件</strong>：“回退N步”就来源于出现丢失和时延过长分组时发送方的行为。如果出现超时，发送方将重传所有已发送但还未被确认的分组。如果收到一个ACK，但仍有已发送但未被确认的过的分组，则定时器被重新启动；如果没有已发送但未被确认的过的分组，则停止该计时器。</li>
</ul>
</li>
<li><p><strong>选择重传（SR）</strong></p>
<p>通过让发送方仅重传那些它怀疑在接收方出错的分组（即丢失或受损）而避免了不必要的重传。这种个别的、按需的重传要求接收方逐个确认正确接收的分组。再次用窗口长度N来限制流水线中未完成的、未被确认的分组数。但与GBN不同的是，发送方已经收到了对窗口中某些分组的ACK</p>
</li>
</ul>
</li>
<li><p>面向连接的TCP：之所以是面向连接的，是因为在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先相互“握手”，即它们必须相互发送某些预备报文段，以建立确保数据传输的参数。</p>
<p>这是一种逻辑连接，其共同状态仅保留在两个通信端系统的TCP程序中。并且提供的是<strong>全双工服务</strong>——如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据就能够从进程B流向进程A的同时，也从进程A流向进程B。TCP连接也总是<strong>点对点</strong>，即在单个发送方与单个接收方之间的连接。</p>
<p>在TCP编程中，曾提到过发起连接的这个进程被称为<strong>客户进程</strong>，另一个进程被称为<strong>服务器进程</strong>。客户应用进程首先要通知客户运输层它要与服务器上的一个进程来建立一条连接，这个过程通过connect()函数来实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span> <span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr_in * serv_addr,<span class="keyword">int</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>sockaddr_in的对象serv_addr携带有服务器进程的端口、IP地址等信息。</p>
</li>
<li><p>TCP报文段结构：首部包括——<strong>源端口号和目的端口号</strong>、32比特的<strong>序号字段</strong>，32比特的<strong>确认号字段</strong>，16比特的<strong>接收窗口字段</strong>，4比特的<strong>首部长度字段</strong>，可选与变长的<strong>选项字段</strong>，6比特的<strong>标志字段</strong></p>
<ul>
<li><p><strong>序号与确认号</strong>：这是TCO报文段首部中最重要的两个字段，它们保证了TCP的可靠传输服务。</p>
<p>在TCP中，它将数据看作一个无结构、有序的字节流。要注意的是，<strong>一个报文段的序号</strong>是该报文段首字节的字节流编号。而<strong>确认号</strong>是指一个主机期望从另一个主机收到的下一个字节的序号。举个例子：</p>
<p>主机A向主机B发送一个字符C，当用键入“C”并按下回车键后，发送的报文段简单来说就是“Seq=42，ACK=79，data=’C’”；主机B收到“C”后，回显”C”，报文段就是“Seq=79，ACK=43，data=’C’”；主机A再确认收到回显的”C”，报文段就是“Seq=43，ACK=80”</p>
</li>
</ul>
</li>
<li><p>同rdt协议一样，TCP也采用超时/重传机制来处理报文段的丢失问题。但要注意的问题就是超时间隔长度的设置。虽然，超时间隔必须大于该连接的往返时间（RTT）</p>
<ul>
<li><p>往返时间的估计</p>
<p>报文段的样本RTT（即SampleRTT）就是从某报文段被发出到对该报文段的确认被收到之间的时间量。大多数的TCP实现仅在某个时刻做一次SampleRTT测量，而不是为每个发送的报文段测量一个SampleRTT。这也就是说，在任意时刻，仅为一个已发生的但目前尚未被确认的报文段估计SampleRTT，从而产生一个接近每个RTT的新SampleRTT值。同时，TCP也决不会为已被重传的报文段计算SampleRTT；它仅为传输一次的报文段测量SampleRTT。</p>
<p>由于设备等的原因，SampleRTT是一个波动的值，所以为了估计一个典型的RTT，需要设计一个公式来对SampleRTT求取平均值EstimateRTT：<br>$$<br>EstimateRTT = (1-\alpha)EstimateRTT+\alpha SampleRTT<br>$$<br>$\alpha$的值一般取为0.125，也就是EstimateRTT是SampleRTT的一个加权平均值，但这个加权平均值对最近的样本赋予的权值要大于对旧样本赋予的权值。</p>
<p>此外还定义了RTT的偏差值DevRTT，用于估算SampleRTT一般会偏离EstimateRTT的程度：<br>$$<br>DevRTT = (1-\beta)DevRTT+\beta |SampleRTT-EstimateRTT|<br>$$<br>$\beta$的值一般取为0.25，DevRTT是一个SampleRTT与EstimateRTT之间差值的EWMA（<strong>指数加权移动平均</strong>）</p>
</li>
<li><p>设置和管理重传超时间隔</p>
<p>TCP的超时间隔就应该根据EstimateRTT和DevRTT的值来进行设计。</p>
<p>设这个新的变量为TimeoutInterval，与上述两个变量的关系式就为：<br>$$<br>TimeoutInterval = EstimateRTT + 4DevRTT<br>$$<br>设计原理为：TimeoutInterval的值必须大于EstimateRTT，以避免造成不必要的重传；但也不能大太多，否则当报文段丢失时，TCP不能很快地重传该报文段，导致数据传输时延大。所以就在EstimateRTT的基础上增加了一个余量：当SampleRTT波动较大时，就增大这个余量；当波动较小时，就减小这个余量，于是就使用了DevRTT</p>
<p>在标准文档中，推荐的初始TimeoutInterval值为1秒。同时当出现超时后，TimeoutInterval值将加倍，以免即将被确认的猴急报文段过早出现超时。一旦收到报文段并更新EstimateRTT，就使用上述的公式对TimeoutInterval进行再次计算。</p>
</li>
</ul>
</li>
<li><p>TCP发送方有三个与发送和重传有关的主要事件：从上层应用程序接收数据、定时器超时、接收ACK</p>
<p>①第一个主要事件发生：TCP从应用程序接收数据。将数据封装在一个报文段中，并把该报文段交给IP。</p>
<p>②如果定时器还没有为某些其他的报文段而运行，则当报文段被传给IP时，TCP就启动该定时器。</p>
<p>③第三个主要事件发生：TCP将ACK的值y与它的变量SendBase进行比较。TCP状态变量SendBase是最早未被确认的字节的序号，也就是说SendBase-1是指接收方已正确按序接收到的数据的最后一个字节的序号。TCP采取累计确认，所以y确认了字节编号在y之前的所有字节都已经收到。如果$y &gt; SendBase$，则该ACK是在确认一个或多个先前未被确认的报文段。所以发送方就更新SendBase变量；如果当前有未被确认的报文段，TCP还需要重启定时器。</p>
</li>
<li><p>TCP的差错恢复机制是GBN协议还是SR协议？都不是任意的单一，而是GBN协议与SR协议的混合体</p>
<p>①TCP发送方仅需维持已发送到过的但未被确认的字节的最小序号（SendBase）和下一个要发送的字节的序号（NextSeqnum）。但与GBN不同的是，假设发送方将发送一组长度为N的报文段时，并且对任意一个分组n&lt;N，TCP并不会像GBN那样重传分组n的同时还要去重传其所有后继分组，TCP至多重传一个报文段，即报文段n。</p>
<p>②TCP的<strong>选择确认</strong>机制允许TCP接收方有选择地确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段。</p>
</li>
<li><p><strong>流量控制服务</strong></p>
</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/07/15/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Hello World</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>


<div class="ds-share share" data-thread-key="自顶而下" data-title="" data-url="http://example.com/2021/07/15/%E8%87%AA%E9%A1%B6%E8%80%8C%E4%B8%8B/"  data-images="https://github.com/IcoveJ/MyBlog/blob/master/01.jpg" data-content="">
    <div class="ds-share-inline">
      <ul  class="ds-share-icons-16">
      	<li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
        <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
        <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
        <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
        <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
      </ul>
      <div class="ds-share-icons-more">
      </div>
    </div>
 </div>
 





</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2021 John Doe
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>