<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>服务器开发（五）网络编程第一个阶段性总结</title>
    <link href="/2021/08/19/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%94%EF%BC%89%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <url>/2021/08/19/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%94%EF%BC%89%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>做一下自己对这个小项目的技术总结：</p><ul><li><p>因为这个小项目是基于的TCP，所以就先聊聊TCP。</p><p>TCP的网络模型其实是很简单的，下面这张图网上一找一大把：</p><p><img src="/2021/08/19/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%94%EF%BC%89%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/MyBlog\hexo\source\images\服务器开发（五）网络编程第一个阶段性总结\01.jpg" alt="01"></p><p>很清晰地阐释了服务端和客户端究竟干了什么，也很清晰的指示了在写代码过程中我们该怎么去写。除非完全是去实现所有的底层，其余的无外乎是调用各个库的接口。</p><p>主要的还是在写代码过程中遇到的，比如超时等问题的解决。</p></li><li><p>socket究竟是什么东西？</p><p>其实socket在我刚写这个项目代码或者刚学网络编程的时候一直没有理解，包括我在内外网上查资料也一直没理解透，始终迷迷糊糊的，尽管我是将《自顶而下》是看完了的（然而笔记到现在都没写完）！</p><p>所以我不得不再次再次翻出这本书，结合《图解TCP/IP》来将其理解。</p><p>在经典的OSI参考模型中，整个网络被分为了七层，从上而下分别为：<strong>应用层</strong>、<strong>表示层</strong>、<strong>会话层</strong>、<strong>传输层</strong>、<strong>网络层</strong>、<strong>数据链路层</strong>、<strong>物理层</strong>。从另一个方面理解，可以将其分为三层：<strong>应用程序</strong>（包括应用层、表示层、会话层）、<strong>操作系统</strong>（包括传输层、网络层）、设<strong>备驱动程序与网络接口</strong>（数据链路层、物理层）。</p><p>根据这些层，我们就能看到在各层之间数据是怎样使用对应层的协议进行的传输：</p><pre><code class=" mermaid">graph TDA[用户进程]--&gt;E[TCP]--&gt;H[IP]B[用户进程]--&gt;F[UDP]--&gt;H[IP]C[用户进程]--&gt;G[ICMP]--&gt;H[IP]D[用户进程]--&gt;H[IP]I[IGMP]--&gt;H[IP]H[IP]--&gt;J[硬件接口]J[硬件接口]--&gt;K[媒体]L[ARP]--&gt;J[硬件接口]M[RARP]--&gt;J[硬件接口]</code></pre><p>这么看起来依然不知道socket是什么以及在哪儿起的作用。</p><p>在维基百科上对socket的解释是：一种操作系统提供的进程间的通信机制——是网络环境中进程间通信的API。应用程序通过它发送或接收数据。通俗点说我们可以将其理解为每一家的门牌号。快递外卖等通过门牌号将东西送至对应的家庭，程序等也就是通过socket将数据送至对应的主机进程。当然这时的socket肯定就包含这台主机进程的IP+端口号。</p><p>于是我们就能在上面的数据传输图中加入socket</p><pre><code class=" mermaid">graph TDI[IGMP]--&gt;H[IP]H[IP]--&gt;J[硬件接口]J[硬件接口]--&gt;K[媒体]L[ARP]--&gt;J[硬件接口]M[RARP]--&gt;J[硬件接口]A[用户进程]--&gt;N[socket]--&gt;G[ICMP]--&gt;H[IP]B[用户进程]--&gt;N[socket]--&gt;E[TCP]--&gt;H[IP]C[用户进程]--&gt;N[socket]--&gt;F[UDP]--&gt;H[IP]D[用户进程]--&gt;N[socket]</code></pre><p>也就是说设计大师们将复杂的TCP/IP协议簇隐藏在了socket接口的后面，对我们这些用户而言。socket就是全部，去组织数据，去符合指定的协议。</p></li><li><p>IO多路复用中的select和epoll</p><p>IO多路复用一共有三种模型：select、poll、epoll。从左到右，其性能变强。</p><p>这次我选择的是IO多路复用中的select模型（因为我太菜了）。</p><p>先说说什么是多路复用：多路是指多个句柄<strong>并发</strong>下来的IO；复用是指复用这一个后台处理程序。</p><p>对于任何一个程序员而言，只要你不是位置最高的那一个，比如雷军，对于剩下的程序员，业务方就是上帝，我们只能服从。他们给我们多少个fd，我们就需要处理多少个，并且最好还要并发起来。</p><p>select模型是非常笨的模型，对于业务方给的所有fd，select模型并不知道哪一个的IO做好了准备，所以它就是去遍历所有的fd，最好的情况就是$O(1)$，最差的情况是$O(n)$，平均下来依然是$O(n)$。此外，每次对select的调用，都需要将fd集合从用户态拷贝到内核态，这也增加了一部分的开销。</p><p>所以select所支持的fd数量一般不要超过2014，否则效率就大大降低了。</p></li><li><p>MySql</p><p>其实准确地说到写这篇总结为止，我对MySql也只能说会用一点点。所以我这里也就总结我会的这一点点。</p><p>我们经常说MySql数据库，实际上MySql只是数据库中的一种。</p><p>数据库，DataBase，简称DB，分为两种：</p><ul><li><p>关系型数据库（SQL）：通过外键关联来建立表与表之间的联系。</p><p>例如：MySQL、Oracle、SQL Server等。</p></li><li><p>非关系型数据库（NOSQL）：数据以对象的形式存储在数据库中，对象之间的关系通过每个对象自身的属性来决定。</p><p>例如：Redis等。</p></li></ul><p>还有个东西叫作数据库管理系统（DataBase Management System，DBMS），用于科学地组织存储、获取维护数据。MySQL也属于这种。</p><p>安装啥的不说了，说说它的操作：（**先提前声明，sql语言命令末尾要加;**）</p><ul><li><p>结构化查询语句分类：四种</p><ul><li>DDL（数据定义语言）：定义和管理数据对象，例如数据库、数据表；使用到的命令包括CREATE、DROP、ALTER<ul><li>创建数据库：create database 数据库名;</li><li>删除数据库：drop database 数据库名;</li><li>查看数据库：show databases;</li><li>使用数据库：use 数据库名;</li></ul></li><li>DML（数据操作语言）：用于操作数据库对象中的数据，使用到的命令包括INSERT、UPDATE、DELETE</li><li>DQL（数据查询语言）：用于查询数据库数据，使用到的命令包括SELECT</li><li>DCL（数据控制语言）：用于管理数据库的编码语言，使用到的命令包括GRANT、commit、rollback</li></ul></li><li><p>数据值和列类型：（列类型是指该列存放的数据类型）</p><p>常规的char、int、float、double就不说了，只是要注意，是没有string类型的！！！！！！！</p></li><li><p>数据表类型：包括MyISAM、InnoDB、HEAP、BOB、CSV等。</p></li><li><p>外键：外键表示的是两个关系之间的相关联系。也就是能够通过外键，实现两个库中的某个相同的列的值是一样的。但是一旦在两个表之间建立了外键，就意味着一个是主表，另一个是子表，要想删掉主表，必须先删掉子表。</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>服务器开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>服务器开发（四）基于select的小型聊天编程③</title>
    <link href="/2021/08/19/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9F%BA%E4%BA%8Eselect%E7%9A%84%E5%B0%8F%E5%9E%8B%E8%81%8A%E5%A4%A9%E7%BC%96%E7%A8%8B%E2%91%A2/"/>
    <url>/2021/08/19/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89%E5%9F%BA%E4%BA%8Eselect%E7%9A%84%E5%B0%8F%E5%9E%8B%E8%81%8A%E5%A4%A9%E7%BC%96%E7%A8%8B%E2%91%A2/</url>
    
    <content type="html"><![CDATA[<p>这也是这个项目的最后一部分了——这个聊天程序的客户端部分。相较于服务端，客户端就简单得多了。</p><p>整个代码的主体我就只分为了两个部分：客户端初始化函数和析构函数</p><p>首先来看客户端初始化函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">initial</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//1 请求协议版本</span><br>    WSADATA wsaData;<br>    <span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsaData);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LOBYTE</span>(wsaData.wVersion) != <span class="hljs-number">2</span> ||<br>        <span class="hljs-built_in">HIBYTE</span>(wsaData.wVersion) != <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请求协议版本失败!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请求协议成功!\n&quot;</span>);<br><br>    <span class="hljs-comment">//2 创建socket</span><br>    chat_client = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);<br>    <span class="hljs-keyword">if</span> (chat_client == SOCKET_ERROR) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;创建socket失败!\n&quot;</span>);<br>        <span class="hljs-built_in">WSACleanup</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;创建socket成功!\n&quot;</span>);<br><br>    <span class="hljs-comment">//3 获取服务器协议地址族</span><br>    sockaddr_in addr = &#123; <span class="hljs-number">0</span> &#125;;<br>    addr.sin_family = AF_INET;<span class="hljs-comment">//协议版本</span><br>    addr.sin_addr.S_un.S_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;192.168.117.1&quot;</span>);<span class="hljs-comment">//绑定的是服务器的ip</span><br>    addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">8000</span>);<span class="hljs-comment">//0 - 65535     10000左右</span><br>    <span class="hljs-comment">//os内核 和其他程序  会占用掉一些端口   80  23  </span><br><br>    <span class="hljs-comment">//4 连接服务器</span><br>    <span class="hljs-keyword">int</span> c = <span class="hljs-built_in">connect</span>(chat_client, (sockaddr*)&amp;addr, <span class="hljs-keyword">sizeof</span> addr);<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;连接服务器失败!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;连接服务器成功!\n&quot;</span>);<br>    std::future&lt;<span class="hljs-keyword">bool</span>&gt;f = std::<span class="hljs-built_in">async</span>(&amp;chat_client::outTime,<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">if</span> (!f.<span class="hljs-built_in">get</span>()|| !<span class="hljs-built_in">login</span>()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;chat_client::chat_client, <span class="hljs-keyword">this</span>)</span></span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (flag) &#123;<span class="hljs-comment">//收到服务器断开的消息</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        string buff;<br>        cout &lt;&lt; <span class="hljs-string">&quot;想说点什么:&quot;</span>;<br>        std::<span class="hljs-built_in">getline</span>(std::cin, buff);<br>        <span class="hljs-keyword">if</span> (buff == <span class="hljs-string">&quot;quit&quot;</span>) &#123;<br>            flag = <span class="hljs-literal">true</span>;<span class="hljs-comment">//准备让接收的线程也退出来。</span><br><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">send</span>(chat_client, buff.<span class="hljs-built_in">c_str</span>(), <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(buff.<span class="hljs-built_in">size</span>()), <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (t.<span class="hljs-built_in">joinable</span>()) &#123;<br>        t.<span class="hljs-built_in">join</span>();<span class="hljs-comment">//等待线程退出</span><br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;已断开连接&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>前三个步骤就不再多说了，基本上每一个TCP/UDP的网络编程，无论是客户端还是服务端都是这几个步骤。</p><p>直接说说与服务器连接成功后的操作。</p><p>①第一个操作是：使用关键字<code>async</code>来异步处理可能出现的超时问题，这里我将超时直接封装成了一个函数<code>outTime</code>，具体实现也没啥大的差异：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">outTime</span><span class="hljs-params">()</span> </span>&#123;<br>fd_set fd = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-built_in">FD_ZERO</span>(&amp;fd);<br><span class="hljs-built_in">FD_SET</span>(chat_client, &amp;fd);<br>timeval st;<br>st.tv_sec = <span class="hljs-number">0</span>;<br>st.tv_usec = <span class="hljs-number">6000</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">select</span>(<span class="hljs-number">0</span>, &amp;fd,&amp;fd,&amp;fd,&amp;st) == <span class="hljs-number">0</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;超时&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建异步实际上就是创建了一个新的线程来执行相关的操作嘛。</p><p>②第二个操作：登录<code>login()</code>。在登录操作中输入登录账号和密码通过套接字传输后，两个输入是在同一个套接字中进行的传输；并且在<code>login()</code>中接收来自服务端的确认信号。</p><p>③第三个操作：也是最后一个操作，进行多人在线的通话。通话之前必须推出接收线程。</p>]]></content>
    
    
    <categories>
      
      <category>服务器开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>服务器开发（三）基于select的小型聊天编程②</title>
    <link href="/2021/08/16/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89%E5%9F%BA%E4%BA%8Eselect%E7%9A%84%E5%B0%8F%E5%9E%8B%E8%81%8A%E5%A4%A9%E7%BC%96%E7%A8%8B%E2%91%A1/"/>
    <url>/2021/08/16/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89%E5%9F%BA%E4%BA%8Eselect%E7%9A%84%E5%B0%8F%E5%9E%8B%E8%81%8A%E5%A4%A9%E7%BC%96%E7%A8%8B%E2%91%A1/</url>
    
    <content type="html"><![CDATA[<p>从这一篇文章开始就是记录自己的编程过程：</p><h1 id="1、头文件"><a href="#1、头文件" class="headerlink" title="1、头文件"></a>1、头文件</h1><p>关于头文件的使用，时至此时我仍旧在思考，在查询：将要用到的所有头文件全部放进一个head.h和分开使用头文件分别对编译会造成何种影响？</p><p>cpp一直以为被人们所称赞的是其高效的运行，但其却又一直被诟病的编译速度，即使是使用同一编译器，cpp的编译速度也比Java等要慢上很多。cpp的编译模型是从头文件到源文件，每一个源文件还都是一个独立的编译单元，编译器的每一次编译都要去硬盘中读取它所需要的头文件，然后再在编译器中解析。</p><p>头文件是一个很奇妙的文件，不论是标准库还是各种功能库，各种头文件之间的包含与被包含的特性，都使得它可谓是牵一发而动全身。若是有过自编STL库的经验，更能理解这里面的各种心酸。所以头文件的妥善使用能够加快编译的速度。</p><p>因此，在这次的项目编程过程中，我将所有需要使用到的头文件都放入了名为head.的自定义头文件中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> HEAD_H_INCLUDED</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HEAD_H_INCLUDED</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _WIN32_WINNT _WIN32_WINNT_WIN10</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mysql.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;tuple&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib,<span class="hljs-meta-string">&quot;libmysql.lib&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib, <span class="hljs-meta-string">&quot;ws2_32.lib&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li><p>_WIN32_WINNT：这个宏是对所使用的操作系统的版本进行声明。笔者之前使用的MingW是32位的，就导致无法正常使用各个线程库，不得已采用了github上开源的MingW库，进而导致在使用过程中出现了<strong>“#error To use the MinGW-std-threads library, you will need to define the macro _WIN32_WINNT to be 0x0501 (Windows XP) or higher”</strong>的报错，就是提醒需要使用更高的版本系统号来正常连接不同的函数和参数。笔者是win10系统，所以就使用了 _WIN32_WINNT_WIN10。具体的对应关系为：</p><p><img src="/2021/08/16/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89%E5%9F%BA%E4%BA%8Eselect%E7%9A%84%E5%B0%8F%E5%9E%8B%E8%81%8A%E5%A4%A9%E7%BC%96%E7%A8%8B%E2%91%A1/MyBlog\hexo\source\images\服务器开发（三）基于select的小型聊天编程②\01.jpg" alt="winnt"></p><p>当然也可以直接在编译器中跳转到这个宏所在的头文件中去。</p></li><li><p>thread库：这是C++11最重要的特性之一。<a href="https://en.cppreference.com/w/cpp/thread%E8%BF%99%E6%98%AFthread%E7%9A%84%E5%9C%A8%E7%BA%BF%E5%B8%AE%E5%8A%A9%E6%89%8B%E5%86%8C%EF%BC%8C%E5%85%B6%E4%B8%AD%E8%BF%98%E5%8C%85%E6%8B%AC%E4%BA%86%E4%B8%80%E4%BA%9BC++11%E4%B9%8B%E5%90%8E%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%82%E8%BF%99%E4%B8%AA%E5%BA%93%E6%8F%90%E4%BE%9B%E4%BA%86%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%E7%9A%84%E6%94%AF%E6%8C%81%E5%A3%B0%E6%98%8E%EF%BC%8C%E5%AE%83%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1%E6%9D%A5%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E3%80%82">https://en.cppreference.com/w/cpp/thread这是thread的在线帮助手册，其中还包括了一些C++11之后的新特性。这个库提供了对线程函数的支持声明，它通过构造一个线程对象来启动一个线程。</a></p></li><li><p>mysql.h：用于连接数据库。主要说一下vscode对Mysql的使用：在编程过程需要在tasks.json的args中同时引入Mysql的include文件夹路径和lib文件夹路径，同时写入命令“-lmysql”来开启Mysqlclient。关于Mysqlclient，在安装Mysql的过程中是不会有它的安装选项的，只能安装上Mysqlserver，所以需要自己手动安装。Linux下就直接使用命令<strong>pip install mysqlclient</strong>进行安装，若报错，可以访问<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#mysqlclient%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E7%89%88%E6%9C%AC%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85%EF%BC%9BWindows%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85%E8%BE%83%E4%B8%BA%E9%BA%BB%E7%83%A6%EF%BC%8C%E9%A6%96%E5%85%88%E5%BE%97%E6%9C%89python%E7%8E%AF%E5%A2%83%EF%BC%8C%E5%9F%BA%E4%BA%8Epython%E7%8E%AF%E5%A2%83%E5%86%8D%E4%BD%BF%E7%94%A8**pip">https://www.lfd.uci.edu/~gohlke/pythonlibs/#mysqlclient找到对应的版本进行安装；Windows下的安装较为麻烦，首先得有python环境，基于python环境再使用**pip</a> install mysqlclient**命令。只有安装了Mysqlclient，编译器才能正常找到mysql下的C++的API</p></li><li><p>tuple库：也是C++11中的一个重要特性。它的对象是一个固定大小的不同类型值的集合，相当于泛化了的std::pair。可以将它的对象视为一个通用的结构体来使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">tuple&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">int</span>&gt;p;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span>&#123;</span><br>    <span class="hljs-keyword">char</span>* a;<br>    <span class="hljs-keyword">int</span> b;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>mutex库：互斥锁库，也是C++11中提供的。有三个衍生库：recursive_mutex(递归型)、time_mutex(定时型)、recursive_timed_mutex(定时递归型)。锁的机制是为了保证在任意时候只有一个线程在访问公共资源，因为多个线程竞争同一个公共资源，会引发线程安全问题。锁是个很复杂但也很重要的东西，以后再单独写笔记了。</p></li><li><p>#pragma comment(lib,”libmysql.lib”)<br>#pragma comment(lib, “ws2_32.lib”)：#pragma comment(lib, “xxx.lib”)这是visual studio中使用的，以使程序能够调用相应的动态链接库。（但我不知道为什么，我在这儿写入了链接到mysql的lib，但依然要在tasks.json中写明才能正确使用，可能是我姿势不正确吧）</p></li></ul><h1 id="2、客户端头文件（server-h）"><a href="#2、客户端头文件（server-h）" class="headerlink" title="2、客户端头文件（server.h）"></a>2、客户端头文件（server.h）</h1><p>私有变量我分为了四个板块：</p><ul><li><p>```c++<br>fd_set allsocket;<br>sockaddr_in caddr;<br>set<socket> ClientSet;<br>deque&lt;std::pair&lt;socket, const char*&gt;&gt; msgDeque;<br>socket serverSocket;</socket></p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><br>  这服务器所需要的变量<br><br>  + allsocket：fd_set数据类型，用来存放所有连接的<span class="hljs-keyword">socket</span><br>  + caddr：sockaddr_in数据类型，一般只用前三个参数：sin_famili——地址簇，sin_port——<span class="hljs-number">16</span>位的TCP/UDP端口号，sin_addr——<span class="hljs-number">32</span>位的IP地址<br>  + ClientSet：客户端<span class="hljs-keyword">socket</span>集合，因为客户端发送消息非常的频繁并且每一个<span class="hljs-keyword">socket</span>都是唯一的，所以使用<span class="hljs-keyword">set</span>关联式容器。<br>  + msgDeque：消息队列，它的每一个值都是一个键值对pair，每一对值包括了一个<span class="hljs-keyword">socket</span>和<span class="hljs-keyword">socket</span>上的数据。<br>  + serverSocket：服务端的套接字<br><br>+ ```c++<br>  map&lt;<span class="hljs-keyword">socket</span>, <span class="hljs-keyword">string</span>&gt; repeat_login_1;<br>  map&lt;<span class="hljs-keyword">socket</span>, <span class="hljs-keyword">string</span>&gt; repeat_login_2;<br></code></pre></td></tr></table></figure><p>用于处理登录的两个数据结构</p></li><li><p>```c++<br>MYSQL conn;<br>MYSQL_RES* res_set;<br>MYSQL_ROW row;<br>bool mysql_flag = false;<br>deque&lt;tuple&lt;socket, string, string&gt;&gt; mq_deque;</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>  这是数据库所需要的变量<br><br>  + MYSQL_RES结构体：包含了从数据库中查询到的数据<br>  + MYSQL_ROW：本质上是一个<span class="hljs-keyword">char</span> **类型<br>  + mq_deque：用于存放套接字和登录账号、密码<br><br>+ ```C++<br>  std::mutex repeat_socket;<br></code></pre></td></tr></table></figure><p>为之后给thread对象上锁做准备</p></li></ul><p>接下来是公有变量，包括主要的功能函数：</p><ul><li><p>```c++<br>server();<br>int socket_init();<br>void broadcast();<br>bool mysql_initial(const string&amp; usename, const string&amp; password);<br>void login(SOCKET client);<br>string select_usename(string&amp; loginNumber);<br>virtual ~server();<br>string ip;</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>+ `server<span class="hljs-literal">()</span>`：构造函数。在构造函数中我们也要实现对数据库的初始化，整体代码如下：<br><br>  ```c++<br>  server_initial::server<span class="hljs-literal">()</span> &#123;<br>  mysql<span class="hljs-constructor">_init(&amp;<span class="hljs-params">conn</span>)</span>;<span class="hljs-comment">//数据库初始化</span><br>  <span class="hljs-keyword">if</span> (!mysql<span class="hljs-constructor">_real_connect(&amp;<span class="hljs-params">conn</span>, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-string">&quot;xxxx&quot;</span>, <span class="hljs-string">&quot;xxxxxx&quot;</span>, <span class="hljs-string">&quot;xxxx&quot;</span>, 3306, NULL, 0)</span>) &#123;<br>  fprintf(stderr, <span class="hljs-string">&quot;Failed to connect to database: Error: %s\n&quot;</span>,mysql<span class="hljs-constructor">_error(&amp;<span class="hljs-params">conn</span>)</span>);<br>  mysql_flag = <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>  fprintf(stderr, <span class="hljs-string">&quot;数据库创建成功!\n&quot;</span>);<br>  mysql<span class="hljs-constructor">_set_character_set(&amp;<span class="hljs-params">conn</span>, <span class="hljs-string">&quot;gbk&quot;</span>)</span>;<span class="hljs-comment">//设置编码集</span><br>  mysql_flag = <span class="hljs-literal">true</span>;<br>  &#125;<br>  socket<span class="hljs-constructor">_init()</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>mysql_init</code>：数据库的初始化函数，用文档的话来说就是“分配或初始化适合<code>mysql_real_connect</code>的<code>MYSQL</code>对象”，其API是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">MYSQL *<span class="hljs-title">mysql_init</span><span class="hljs-params">(MYSQL *mysql)</span></span><br></code></pre></td></tr></table></figure><p>它的参数是<code>MYSQL</code>对象的指针。要注意的是，根据其官方文档所说：使用<code>mysql_init</code>会根据需要自动地调用<code>mysql_library_init</code>接口。并且<code>mysql_library_init</code>在多线程环境中不是线程安全的，也就导致<code>mysql_init</code>在多线程中也不是安全的。</p><p>其实我在使用这个函数之前是没有查阅过官方文档的，仅仅是根据库里面的函数来进行的编程，所以就没有按照官方文档对这个函数进行使用，也就是：无论是主动调用<code>mysql_library_init</code>还是通过<code>mysql_init</code>来调用，都必须在生成任何线程之前调用<code>mysql_library_init</code>，或者使用互斥锁来保护这个调用。</p></li><li><p><code>mysql_real_connect</code>：与你本地<code>mysql</code>的<code>database</code>建立连接。其API是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">MYSQL *<span class="hljs-title">mysql_real_connect</span><span class="hljs-params">(MYSQL *mysql, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *host, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *user, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *passwd,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *db, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> port, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *unix_socket, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> client_flag)</span></span><br></code></pre></td></tr></table></figure><ul><li>第一个参数就是通过<code>mysql_init</code>初始化的对象</li><li>第二个参数是你本地<code>mysql</code>的地址，可以是<code>host</code>或者是<code>127.0.0.1</code></li><li>第三个参数是你本地<code>mysql</code>的用户名称</li><li>第四个参数是你本地<code>mysql</code>的用户密码</li><li>第五个参数是你想将你接下来的数据所存储到的本地数据库<code>database</code>的名称</li><li>第六个参数是你本地<code>mysql</code>的端口</li><li>接下来两个参数并不咋重要，也可能是我没咋用过，所以就可以直接分别置为NULL和0</li></ul></li><li><p><code>mysql_set_character_set</code>：设置使用<code>mysql_real_connect</code>进行连接的默认字符集。其API是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mysql_set_character_set</span><span class="hljs-params">(MYSQL *mysql, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *csname)</span></span><br></code></pre></td></tr></table></figure><p>字符集就比如说是UTF-7，GB2312等。可以通过命令<code>show variables like ‘%character%’;</code>来查阅本地<code>mysql</code>的字符集。</p></li><li><p><code>int socket_init()</code>：初始化套接字的函数。代码分步骤进行说明：</p><p>对套接字的初始化的过程其实是非常有顺序的，哪一步该干嘛，都是按照网络通信模型来进行的编程，区别就在于不同的模型，使用不同的接口函数来进行通信。</p><ul><li><p>第一步：请求协议版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">WSADATA wsaData;<br>WORD sockVersion = <span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">WSAStartup</span>(sockVersion, &amp;wsaData);<br><span class="hljs-comment">// if (WSAStartup(sockVersion, &amp;wsaData) != 0)</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">LOBYTE</span>(wsaData.wVersion) != <span class="hljs-number">2</span> || <span class="hljs-built_in">HIBYTE</span>(wsaData.wVersion) != <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请求协议版本失败!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请求协议成功!\n&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li><code>WSADATA</code>：<code>winsock.h</code>中的一种数据结构，用来存储调用<code>WSAStartup</code>后返回的<code>Windows Sockets</code>数据。</li><li><code>WORD</code>与<code>MAKEWORD</code>：<code>MAKEWORD</code>是将两个byte型合并成一个word型，一个在高8位，一个在低8位。2意味着能够接收信息后就能够立即发送，设置为1的话，只能一次接收一次，并且不能马上发送。</li><li><code>WSAStartup</code>：使用<code>Socket</code>的程序在使用<code>Socket</code>之前必须调用<code>WSAStartup</code>函数，操作系统会根据请求的<code>Sockst</code>版本</li><li>之后对请求协议版本是否成功的写法有两种：①使用<code>LOBYTE()</code>和<code>HIBYTE()</code>函数来对<code>wVersion</code>进行分析；②直接判断<code>WSAStartup</code></li></ul></li></ul><ul><li><p>第二步：创建socket</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">serverSocket = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);<br><span class="hljs-keyword">if</span> (serverSocket == SOCKET_ERROR) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;创建socket失败!\n&quot;</span>);<br>    <span class="hljs-built_in">WSACleanup</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;创建socket成功!\n&quot;</span>);<br></code></pre></td></tr></table></figure><p>主要就是使用<code>socket()</code>函数来创建套接字，它的三个参数依次分别代表要使用的协议簇、套接字类型、传输协议类型</p></li><li><p>第三步：设置服务器的IP地址和端口号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">sockaddr_in addr;<br>addr.sin_family = AF_INET;<br>addr.sin_port = <span class="hljs-built_in">htons</span>(xxxx);<br>addr.sin_addr.S_un.S_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;xxx.xxx.xxx.xxx&quot;</span>);<br><span class="hljs-comment">// inet_pton(AF_INET, &quot;xxx.xxx.xxx.xxx&quot;, (void*)&amp;sin.sin_addr.S_un.S_addr)</span><br></code></pre></td></tr></table></figure><ul><li>使用<code>sockaddr_in</code>结构体，有三个数据：端口号<code>sin_port</code>，是<code>unsigned short</code>类型；协议簇<code>sin_family</code>，是<code>short</code>类型；用于解析IP地址的<code>sin_addr</code>，它的类型是结构体<code>in_addr</code>，在<code>in_addr</code>中的<code>S_un.S_addr</code>能够得到来自于<code>inet_addr</code>函数所解析得到的IP地址。</li><li>也可以通过使用<code>inet_pton</code>函数来完成IP地址的解析，这两种方法是完全等价的</li><li>要注意的是在解析端口时，需要使用<code>htons</code>将本机字节序转换为网络字节序</li></ul></li><li><p>第四步：将套接字描述符绑定在服务器地址上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(serverSocket, (LPSOCKADDR)&amp;addr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(addr)) == SOCKET_ERROR) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bind失败!\n&quot;</span>);<br>    <span class="hljs-built_in">closesocket</span>(serverSocket);<br>    <span class="hljs-built_in">WSACleanup</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bind成功!\n&quot;</span>);<br></code></pre></td></tr></table></figure><p>使用<code>bind</code>函数来完成这个绑定。要注意的是，若没有绑定成功一定要使用<code>closesocket</code>关闭当前的套接字并使用<code>WSACleanup</code>来解除与<code>Socket</code>库的绑定以及释放相关资源。</p></li><li><p>第五步：监听套接字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> r = <span class="hljs-built_in">listen</span>(serverSocket, <span class="hljs-number">10</span>);<br><span class="hljs-keyword">if</span> (r == <span class="hljs-number">-1</span>) &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;listen失败!\n&quot;</span>);<br>  <span class="hljs-built_in">closesocket</span>(serverSocket);<br>  <span class="hljs-built_in">WSACleanup</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;listen成功!\n&quot;</span>);<br></code></pre></td></tr></table></figure><p>使用<code>listen</code>函数来完成对套接字的监听，它的第一个参数是套接字。第二个参数是设置连接队列的长度。同<code>bind</code>一样，若是监听失败，也要执行关闭当前套接字等一系列操作。</p></li><li><p>第六步：等待客户端的连接<br>在连接客户端之前还有三个操作：①调用<code>FD_ZERO</code>清空文件句柄集并调用<code>FD_SET</code>将监听到的套接字添加到集合中；②设置时间参数st，为<code>select</code>的调用工作准备；③调用一个线程来广播消息，以实现每个用户能够接收到来自其他用户的消息，<code>broadcast</code>的具体实现之后再说；<br>关于客户端连接的具体实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    fd_set tmpSocket = allsocket;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-built_in">select</span>(<span class="hljs-number">0</span>, &amp;tmpSocket, <span class="hljs-literal">NULL</span>, &amp;tmpSocket, <span class="hljs-literal">NULL</span>);<br>    cout &lt;&lt; num &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>)&#123;<br>      cout &lt;&lt; <span class="hljs-string">&quot;超时！&quot;</span> &lt;&lt; endl;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">for</span> (u_int i = <span class="hljs-number">0</span>; i &lt; tmpSocket.fd_count; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (tmpSocket.fd_array[i] == serverSocket) &#123;<br>          SOCKET clientsocket = <span class="hljs-built_in">accept</span>(serverSocket, (sockaddr*)&amp;cAddr, &amp;len);<br>          <span class="hljs-keyword">if</span> (clientsocket == INVALID_SOCKET) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;绑定失败&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>          &#125;<br>          <span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;server_initial::login,<span class="hljs-keyword">this</span>,clientsocket)</span></span>;<br>          t.<span class="hljs-built_in">detach</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">char</span> buff[<span class="hljs-number">1500</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>          cout &lt;&lt; buff &lt;&lt; endl;<br>          <span class="hljs-keyword">int</span> r = <span class="hljs-built_in">recv</span>(tmpSocket.fd_array[i], buff, <span class="hljs-number">1499</span>, <span class="hljs-number">0</span>);<br>          <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">auto</span> close_client_socket = tmpSocket.fd_array[i];<br>            clientSet.<span class="hljs-built_in">erase</span>(close_client_socket);<br>            <span class="hljs-built_in">FD_CLR</span>(tmpSocket.fd_array[i], &amp;allsocket);<br>            <span class="hljs-built_in">closesocket</span>(close_client_socket);<br>            string close_loginNumber = repeat_login_2[close_client_socket];<br>            repeat_login_1.<span class="hljs-built_in">erase</span>(close_loginNumber);<br>            repeat_login_2.<span class="hljs-built_in">erase</span>(close_client_socket);<br>            cout &lt;&lt; <span class="hljs-string">&quot;关闭连接&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>          &#125;<br><br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r &gt; <span class="hljs-number">0</span>) &#123;<br>            buff[r] = <span class="hljs-number">0</span>;<br>            msgdeque.<span class="hljs-built_in">emplace_back</span>(std::<span class="hljs-built_in">make_pair</span>(tmpSocket.fd_array[i], buff));<br>            cout &lt;&lt; repeat_login_2[tmpSocket.fd_array[i]] &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; buff &lt;&lt; endl;<br>          &#125;<br>          <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> err = <span class="hljs-built_in">WSAGetLastError</span>();<br>            <span class="hljs-keyword">if</span> (err == <span class="hljs-number">10054</span>) &#123;<br>              <span class="hljs-keyword">auto</span> close_client_socket = tmpSocket.fd_array[i];<br>              clientSet.<span class="hljs-built_in">erase</span>(close_client_socket);<br>              <span class="hljs-built_in">FD_CLR</span>(tmpSocket.fd_array[i], &amp;allsocket);<br>              <span class="hljs-built_in">closesocket</span>(close_client_socket);<br>              cout &lt;&lt; <span class="hljs-string">&quot;错误退出&quot;</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; err &lt;&lt; endl;<br>            &#125;<br>            <span class="hljs-keyword">continue</span>;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">0</span>)&#123;<br>      cout &lt;&lt; <span class="hljs-string">&quot;select函数出错了&quot;</span> &lt;&lt;<span class="hljs-built_in">WSAGetLastError</span>()&lt;&lt; endl;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>①首先是一个<code>while</code>循环。因为<code>select</code>最重要的特点就是通过轮询的方式去查询连接</li><li>②将之前得到的套接字集合赋值给一个新的套接字，因为每次<code>select</code>操作后之前<br>监听到的<code>fd_set</code>集合都被置为了0，所以就需要在每次轮询前都对其进行新的赋值。</li><li>③<code>select</code>操作：<code>select(0, &amp;tmpSocket, NULL, &amp;tmpSocket, NULL)</code>在这儿的版本实际上改动后的，没有使用到之前设置的时间参数st，因为我在使用过程中一直出现超时的情况，也即<code>select</code>的返回值一直是0，这是因为整个代码在执行过程中，在<code>select</code>之间就出现了阻塞，所以我就设置为了阻塞的模式，以避免后续再出现超时的情况。这也就导致，当启动服务端程序之后，服务端程序必须等待客户端程序发来消息才能继续执行下一步操作。</li><li>④当<code>select</code>成功后，就对集合中的套接字与之前监听到的套接字进行匹配，若匹配成功，就使用<code>accept</code>根据这个套接字接受来自客户端的请求</li><li>⑤匹配成功后使用新的线程接收来自客户端的登录账号和密码，这里就会调用<code>login()</code>函数。在<code>login()</code>函数的登录成功情况中，主要的是两个部分：第一个部分是与数据表建立连接，所以要事先建好数据库及数据表；第二个部分是与数据库建立连接后，就向服务端反馈信息。</li></ul><p>以上便是服务端的全部编程思想及实现。</p></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>服务器开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>服务器开发（二）基于select的小型聊天编程①</title>
    <link href="/2021/08/15/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9F%BA%E4%BA%8Eselect%E7%9A%84%E5%B0%8F%E5%9E%8B%E8%81%8A%E5%A4%A9%E7%BC%96%E7%A8%8B%E2%91%A0/"/>
    <url>/2021/08/15/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9F%BA%E4%BA%8Eselect%E7%9A%84%E5%B0%8F%E5%9E%8B%E8%81%8A%E5%A4%A9%E7%BC%96%E7%A8%8B%E2%91%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h1><p>这是我个人在学习了《Linux网络编程》《计算机网络：自顶而下》之后，做的第一个超小型项目，单纯练练手。并记录下编程过程中所遇到的问题，以及使用vscode过程中所遇到的问题。</p><p>其次，由于个人电脑linux端出现了一点问题，因此这次项目的编程环境是：</p><ul><li>Windows10</li><li>MySql-8.0.11-winx64</li><li>vscode + gcc8.1.1(x76_64-posix-seh-rev0)</li></ul><h1 id="1、模型选择"><a href="#1、模型选择" class="headerlink" title="1、模型选择"></a>1、模型选择</h1><p>在这个项目中我使用的是select模型，而不是传统的C/S模型，也不是多路复用中的其他几种模型（poll、epoll等）。因为它基本解决了C/S模型中accept()、recv()、send()等阻塞的问题。</p><p>相较于C/S模型，select模型的好处在于单个process能够同时处理多个网络连接的IO。基本原理就是select函数能够不断地去<strong>轮询</strong>所负责的所有socket，一旦某个socket有数据到达了，就去通知用户process去调用read操作，将数据从kernel拷贝到用户process。</p><p><img src="/images/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%E5%9F%BA%E4%BA%8Eselect%E7%9A%84%E5%B0%8F%E5%9E%8B%E8%81%8A%E5%A4%A9%E7%BC%96%E7%A8%8B%E2%91%A0/select01.png" alt="select01"></p><p>正如图例所示：用户先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。有数据到达时，socket被激活，select函数返回。用户process正式发起read请求，从kernel中读取数据并放回用户process中。</p><p>从这个流程上来看，使用select函数来进行IO操作似乎与同步阻塞没啥区别，甚至select还需要监视更多的socket从而导致效率变差。但这个缺点也正是它的最大优势：同时处理多个socket的IO请求。也就是能够达到同一线程内同时处理多个IO请求。</p><p>select函数在Windos中的&lt;WinSock.h&gt;下，linux中的&lt;sys/select.h&gt;下，其API为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">select</span>(<br>    _In_ <span class="hljs-keyword">int</span> nfds,<br>    _Inout_opt_ fd_set FAR * readfds,<br>    _Inout_opt_ fd_set FAR * writefds,<br>    _Inout_opt_ fd_set FAR * exceptfds,<br>    _In_opt_ <span class="hljs-keyword">const</span> struct timeval FAR * timeout<br>    );<br></code></pre></td></tr></table></figure><ul><li>nfds：所有文件描述符的最大值加1。linux中默认的最大值是1024，这样设置的好处是能够减少轮询时间以及系统的开销。忽略时将其置为0</li></ul><p>之后的三个参数都是fd_set类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fd_set</span>&#123;</span><br>    u_int fd_count;<br>    SOCKET fd_array[FD_SETSIZE];<br>&#125;fd_set;<br></code></pre></td></tr></table></figure><p>默认情况下，FD_SETSIZE的值为64，可以在头文件中进行更改。fd_count就是集合中文件描述符的个数。</p><ul><li><p>readfds：检查是否有可读的socket</p></li><li><p>writefds：检查是否有可写的socket</p></li><li><p>exceptfds：检查socket上的异常错误</p></li><li><p>timeout：最大等待时间。它的结构体为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> &#123;</span><br>        <span class="hljs-keyword">long</span>tv_sec;<span class="hljs-comment">//以秒为单位</span><br>        <span class="hljs-keyword">long</span>    tv_usec;<span class="hljs-comment">//以毫秒为单位</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h1 id="2、实现功能"><a href="#2、实现功能" class="headerlink" title="2、实现功能"></a>2、实现功能</h1><p>我初步想设计的功能包括：内/外网的联通、多人线上的聊天、以及一些在登录过程和聊天过程中的一些细节吧。</p><p>在后面代码过程中，再说。</p>]]></content>
    
    
    <categories>
      
      <category>服务器开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>服务器开发（一）分布式、多线程、高并发</title>
    <link href="/2021/08/13/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    <url>/2021/08/13/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p>在尝试着做服务器方面的项目开发，之前也对分布式、高并发、多线程有过一定的了解，但并未有过系统的认识，固去做深入的理解，并记录。</p><h1 id="1、分布式系统"><a href="#1、分布式系统" class="headerlink" title="1、分布式系统"></a>1、分布式系统</h1><p>分布式系统在上世纪末期就被提出，后被Google发扬光大，熟悉的MapReduce、BigTable等都是基于的分布式系统。</p><p>什么是分布式系统？在网上看到过两个比较好的解释：</p><p>①a system with multiple components located on different machines that communicate and coordinate actions in order to appear as a single coherent system to the end-user.</p><p>②A distributed system is a system which has unbounded latency and experiences partial failure.</p><p>个人认为这两句话将分布式系统的特点都很清晰地进行了解释。</p><p>在第一种解释中，分布式系统简单来说就是对一个终端用户而言，这个系统虽然是通过多个分布在不同机器上的组件通力合作实现的，但它看起来就是一个机器在工作。</p><p>在第二种解释中，分布式系统的各个组件之间是存在不确定的延迟的，并且其中的一些组件还可能宕机。</p><p>于是我们就能得到分布式系统的几个重要特点：</p><ul><li>分布性</li><li>对等性：分布式系统中的计算机是没有主从之分的，没有绝对的控制与被控制</li><li>故障总是会发生</li></ul><p>此外，他还有两个重要的特性：并发性和缺乏全局时钟</p><p>分布式存在的意义是什么？或者说为什么要用它呢？</p><p>分布式系统的提出主要是解决集中式系统三个方面的不足：系统复杂性、可拓展性、容错性。</p><p>它有两种工作方式：</p><ul><li>分布式系统的每个机器都朝着同一个目标工作，终端用户将其视为一个结果</li><li>每个机器都有自己的终端用户，也就是说终端用户的个数不再是一个，此时分布式系统起共享资源或通信服务的作用</li></ul><p>第二种工作方式最经典的例子就是CS（Client/Server）模型。</p><h1 id="2、高并发"><a href="#2、高并发" class="headerlink" title="2、高并发"></a>2、高并发</h1><p>在分布式中提到过分布式系统有一个重要的特性是并发性。高并发就是指一中系统在运行过程中遇到的“短时间内遇到大量请求操作”的情况，经常出现在web系统中，例如双十一的电商平台、遭遇抢票时的12306等。也就是说，高并发就代表着大流量。</p><p>它的处理指标通常有：</p><ul><li>响应时间（Response Time）：系统对请求做出的响应时间。</li><li>吞吐量（Throughput）：单位时间内处理的请求数量。</li><li>每秒查询率QPS（Query Per Second）：每秒响应请求数。</li><li>并发用户数：同时承载正常使用系统功能的用户数量。</li></ul><h1 id="3、多线程"><a href="#3、多线程" class="headerlink" title="3、多线程"></a>3、多线程</h1><p>先声明，多线程<strong>不等于</strong>高并发。</p><p>多线程是一种处理并发的技术，旨在从软件<strong>或</strong>硬件上实现多个线程并发执行的技术，解决的是CPU调度多个线程的问题。</p><p>线程一共有六个状态：新建、运行、阻塞、等待、计时等待和终止。但给定一个时间点，线程只能有一种状态。</p><p>多线程就能够实现：</p><ul><li>更高的运行效率</li><li>模块化的编程</li><li>更小的创建和切换开销</li><li>更方便的通信</li><li>更简洁化的程序结构和更高的资源利用率</li></ul>]]></content>
    
    
    <categories>
      
      <category>服务器开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++学习：单双冒号的用法</title>
    <link href="/2021/08/11/C-%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%8D%95%E5%8F%8C%E5%86%92%E5%8F%B7%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <url>/2021/08/11/C-%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%8D%95%E5%8F%8C%E5%86%92%E5%8F%B7%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>学习muduo源码中，发现了自己之前未见过的函数写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">ssize_t</span> nr = ::<span class="hljs-built_in">read</span>(sockfd, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(buf) + nread, length - nread);<br></code></pre></td></tr></table></figure><p>对双冒号的用法感到不解，于是咨询学长+查资料，彻底总结一下单双冒号的用法：</p><p><strong>单冒号(:)：</strong></p><ul><li><p>表示结构体中位域的定义，具体形式就是：类型说明符 位域名: 位域长度。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span>&#123;</span><br>    <span class="hljs-keyword">int</span> a:<span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">int</span> b:<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> c:<span class="hljs-number">6</span>;<br>&#125;data;<br></code></pre></td></tr></table></figure><p>这么做是为了节省存储空间，并使处理更简便。因为某些信息在存储时并不需要占用一个完整的字节。在上面这个例子中，data为A的变量，共占两个字节（8位+2位+6位 = 16位 = 8位 * 2），其中位域a占8位，位域b占2位，位域c占6位。</p><p>使用位域要注意几点：</p><ul><li>一个位域必须存储在同一个字节中，即使某字节剩余的位不足以存储下一个位域，那也应该从下一个字节起存放这个位域。</li><li>每一个位域不能超过8位。</li><li>位域可以没有名字，但只能起到调节位置或填充的作用，不能用于其他功能上的使用。</li><li>位域的使用与其他结构成员是一样的。</li></ul></li><li><p>用于结构体的初始化列表赋值，具体形式是：结构体(参数名1，参数名2):参数名1(实参)，参数名2(实参){};例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(string a, <span class="hljs-keyword">int</span> b):<span class="hljs-built_in">a</span>(<span class="hljs-string">&quot;jiang&quot;</span>),<span class="hljs-built_in">b</span>(<span class="hljs-number">1</span>)&#123;&#125;;<br>    <span class="hljs-keyword">private</span>:<br>    string a; <span class="hljs-keyword">int</span> b;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>定义类的继承，具体形式就是：类生派名:继承方式 基类名。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">int</span> b;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>:</span><span class="hljs-keyword">public</span> A&#123;<span class="hljs-comment">// B以公有的方式继承A</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> c;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p><strong>双冒号(::)：</strong></p><ul><li><p>域操作符。多用于在类中声明、类外定义的函数</p></li><li><p>直接使用在全局函数之前，多用于当全局变量在局部函数中与其中某个变量重名的情况。这里就是本篇一开始的那个例子。</p><p>这种方法还衍生出了另一种用途：对全局变量的值进行截断修改。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span>;<br>    cout &lt;&lt; a &lt;&lt; endl;<span class="hljs-comment">// 访问局部变量，此时的输出为20</span><br>    <br>    avar = <span class="hljs-number">30</span>;<br>    cout &lt;&lt; a &lt;&lt; endl;<span class="hljs-comment">// 访问局部变量，此时的输出为30</span><br>    <br>    cout &lt;&lt; ::a &lt;&lt; endl;<span class="hljs-comment">// 访问全局变量，此时的输出为10</span><br>    ::a = <span class="hljs-number">40</span>;<br>    cout &lt;&lt; ::a &lt;&lt; endl;<span class="hljs-comment">// 访问全局变量，此时的输出为40</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记/C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++学习：结构体末端定义空数组</title>
    <link href="/2021/08/11/C-%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93%E6%9C%AB%E7%AB%AF%E5%AE%9A%E4%B9%89%E7%A9%BA%E6%95%B0%E7%BB%84/"/>
    <url>/2021/08/11/C-%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93%E6%9C%AB%E7%AB%AF%E5%AE%9A%E4%B9%89%E7%A9%BA%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>在阅读muduo代码的过程中发现了一个末端定义空数组的结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PayloadMessage</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">int32_t</span> length;<br>  <span class="hljs-keyword">char</span> data[<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>陈硕老师对其的讲解是：这个长度为0的数组在C语言中是用来表面这个数组的长度是在运行时决定的，分配多少内存，这个数组就有多长。</p><p>这个结构体的使用是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">PayloadMessage* payload = <span class="hljs-keyword">static_cast</span>&lt;PayloadMessage*&gt;(::<span class="hljs-built_in">malloc</span>(total_len));<br><span class="hljs-comment">//total_len是报文的长度，类型为const int</span><br></code></pre></td></tr></table></figure><p>以前也见过类似的写法，但并未深究，所以这次遇见了选择深入学习一下。</p><p>这是一种广泛使用的几千，常常用来构造缓冲区，尤其是在嵌入式开发中经常使用，与指针相比，它的优势在于：</p><p>①不需要初始化，因为数组的名就是缓冲区数据的起始地址；</p><p>②空数组不占任何空间，而指针不管是否为空，至少都会占4字节的空间。</p><p>由于空数组不占任何的内存空间，就使得在计算结构体的size时，它并不会被计算入内。</p><p>同时若是使用指针，那么再分配内存缓冲区时，就必须分配结构体一次，同时为结构体内的指针分配一次，这样就会产生很麻烦的后果：结构体的内存地址与指针地址是不连续的，申请与释放就需要分别管理吗，并且必须先释放结构体的指针，再释放结构体，次序是不能够颠倒的。</p><p>反过来使用数组，就只需要释放一次。</p><p>简单来说这种技巧就是分配一段连续的内存，来减少内存的碎片化。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记/C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++学习：namespace</title>
    <link href="/2021/08/11/C-%E5%AD%A6%E4%B9%A0%EF%BC%9Anamespace/"/>
    <url>/2021/08/11/C-%E5%AD%A6%E4%B9%A0%EF%BC%9Anamespace/</url>
    
    <content type="html"><![CDATA[<p>在初次学习一门语言时都是从hello world开始的，笔者学习的第一门语言是C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello World!\n&quot;</span>;<span class="hljs-comment">// cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这儿我们聊聊namespace这个名词及其语句！</p><p>正如其名，中文是<strong>命名空间</strong>，using namespace就是<strong>使用这个命名空间</strong>，而之后的std就是所使用的命名空间的名字。命名空间所存放的是各种标识符。std就是C++标准程序库中的所有标识符所存放的地方。</p><p>每一个命名空间都是一个<strong>作用域</strong>，与其他作用域类似，命名空间中的每个名字都必须表示为该空间内的唯一实体。</p><p>为了解决在大规模的程序设计以及程序员在使用各种C++库的过程中所出现的命名冲突问题，在C++11中引入了关键字namespace。</p><p>具体用法如下：</p><p>①namespace的定义类似于struct或class：在关键字namesapce之后紧接空间名字，再接域，但没有最后的分号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> A&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>②namespace的定义必须是全局范围</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 正确定义</span><br><span class="hljs-keyword">namespace</span> A&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 使用命名空间A</span><br>&#125;<br><br><span class="hljs-comment">// 错误定义</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 错误行为：在主函数或自定义函数内定义命名空间</span><br>    <span class="hljs-keyword">namespace</span> A&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>③namespace可以嵌套，但外层命名空间不能直接调用内层命名空间的标识符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> A&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">namespace</span> B&#123;<br>        <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// A想调用b的正确方法是通过调用命名空间B去间接调用</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    cout &lt;&lt; A::a &lt;&lt; endl;<br>    cout &lt;&lt; A::B::b &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>④namespace可以存放变量、函数、结构体等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> A&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; a &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>⑤namespace中的函数可以在域外进行定义，同时要加作用域，但若要在域外定义中使用该该函数所在域中的变量，就不需要加；除非是使用另一个命名空间的变量，即使这个命名空间与这个函数在同一个命名空间中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> A&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">namespace</span> B&#123;<br>        <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">A::f</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">// 函数定义需要表明所在域，</span><br>    cout &lt;&lt; a &lt;&lt; endl;<span class="hljs-comment">// a与f在同一个域中</span><br>    cout &lt;&lt; B::b &lt;&lt; endl;<span class="hljs-comment">// b与f不在同一个域中就需要声明所使用变量的域</span><br>&#125;<br></code></pre></td></tr></table></figure><p>⑥无名命名空间，意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了static，使得其可以作为内部连接</p><p>⑦命名空间之间可以相互赋值，赋值过程也可以在某一个域内，不强求一定是全局的过程。赋值的结果就是完全的复制。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记/C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言中的union及大小端问题</title>
    <link href="/2021/08/09/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84union%E5%8F%8A%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98/"/>
    <url>/2021/08/09/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84union%E5%8F%8A%E5%A4%A7%E5%B0%8F%E7%AB%AF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP</title>
    <link href="/2021/08/09/CSAPP/"/>
    <url>/2021/08/09/CSAPP/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>学习笔记/操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计网-自顶而下-学习笔记</title>
    <link href="/2021/07/15/%E8%AE%A1%E7%BD%91-%E8%87%AA%E9%A1%B6%E8%80%8C%E4%B8%8B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/07/15/%E8%AE%A1%E7%BD%91-%E8%87%AA%E9%A1%B6%E8%80%8C%E4%B8%8B-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-计算机网络与因特网"><a href="#第一章-计算机网络与因特网" class="headerlink" title="第一章 计算机网络与因特网"></a>第一章 计算机网络与因特网</h1><ul><li><p>什么是因特网？</p><p>两种回答方式：①能够描述因特网的具体构成，即构成因特网的基本硬件和软件组成；②能够根据为分布式应用提供服务的联网基础设施来描述因特网。</p><ul><li><p>对①的描述：</p><p>因特网应用程序运行在端系统上，也就是它们并不运行在网络核心中的分组交换机中。即使分组交换机能够加速端系统间的数据交换，但它们并不在意作为数据的源或宿的应用程序。</p></li><li><p>对②的描述：</p><p>将因特网描述为应用程序的平台。</p></li></ul></li><li><p>因特网服务提供商：ISP</p><p>每个ISP自身就是一个由多台<strong>分组交换机</strong>和多段<strong>通信链路</strong>组成的网络</p></li><li><p>分布式应用：涉及多个相互交换数据的端系统的应用程序</p></li><li><p>运行在一个端系统上的应用程序怎么样才能指令因特网向运行在另一个端系统上的软件发送数据呢？</p><p>通过<strong>套接字接口</strong>，该接口规定了运行在另一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的地程序交付数据的方式。</p><p>因特网套接字接口是一套发送程序必须遵循的规则集合。</p></li><li><p>协议：定义了在<strong>两个</strong>或<strong>多个通信实体</strong>之间交换的报文的<strong>格式</strong>和<strong>顺序</strong>，以及报文发送和/或接收一条报文或其他事件所采取的动作。</p></li><li><p>端系统：桌面计算机、服务器、移动计算机</p></li><li><p>主机 = 端系统，但对主机的分类是：客户（client）和服务器（server）。</p></li><li><p>家庭接入网的方式有：DSL，电缆，FTTH，拨号，卫星。</p><ul><li><p>宽带住宅接入的两种类型：数字用户线（DSL）和电缆。</p><p>关于DSL，每个用户的<strong>DSL调制解调器</strong>使用现有的电话线与位于本地中心局（OC）的<strong>数字用户线接入复用器</strong>（DSLAM）交换数据。家庭的DSL调制解调器将得到的数字数据转化成高频音，来自家庭的模拟信号在DSLAM处被转换成数字形式。</p><p>每个用户能接网所依托的就是现有的<strong>电话线</strong>，它同时承载着数据和传统的电话信号，并使用不同的频率进行编码：</p><ul><li><p>高速下行信道：位于50kHz到1MHz频段；</p></li><li><p>中速上行信道：位于4kHz到50kHz频段；</p></li><li><p>普通的双向电话信道：位于0到4kHz频段；</p><p>（ex：上行信道是指用户发给基站所经历的信道，下行信道与之相反）</p></li></ul></li><li><p>电缆因特网接入利用的是<strong>有线电视基础设施</strong>，依托的是<strong>混合光纤同轴系统（HFC）</strong>：<strong>光缆</strong>连接地区枢纽和电缆头端，<strong>同轴光缆</strong>连接每个家庭与电缆头端。</p></li><li><p>FTTH-光纤到户：关于光纤分布方案，有两种：<strong>有源光纤网络（AON）</strong>，<strong>无源光纤网络（PON）</strong>。</p><ul><li><p>AON：本质上是交换以太网</p></li><li><p>PON：在PON中，每个家庭具有一个光纤网络端接器（ONT），由专门的光纤连接到邻近的分配器，这个分配器再把一些家庭集结到一根共享的光纤，这根光纤再连接到本地电话和公司的中心局中的光纤线路端接器（OLT）。OLT提供了光信号与电信号之间的转换。</p><p>在PON体系结构中，所有从OLT发送到分配器的分组在分配器。</p></li></ul></li></ul></li><li><p>物体媒介的作用：对于每个发射器-接收器对，通过跨越一种物理媒介传播电磁波或光脉冲来发送该比特。</p><p>分为两种类型：<strong>导引型媒体</strong>和<strong>非导引型媒体</strong>。前者例如光缆、双绞铜线、同轴电缆，后者例如电波在空气或外层空间中传播</p><p>对于导引型媒体：</p><ul><li>双绞铜线：是高速LAN联网的主导型解决方案，其中无屏蔽双绞线（UTP）常用于局域网LAN。目前局域网的数据传输速率取决于双绞线的粗细以及传输方和接收方间的距离。</li><li>同轴电缆：由两个铜导体组成，但它们是同心的而不是并行的</li><li>光纤：每个脉冲表示一个比特，且不受电磁干扰，所以被用做长途导引型传输媒体，特别是跨海链路。</li></ul><p>对于非导引型媒体：</p><ul><li>陆地无线电信道：极大地依赖于传播环境和信号传输距离。环境上的考虑取决于①路径损耗和遮挡衰落②多径衰落③干扰</li><li>卫星无线电信道：同步卫星和近地轨道</li></ul></li><li><p>网络核心：由<strong>互联因特网端系统</strong>的<strong>分组交换机</strong>和<strong>链路</strong>构成的<strong>网状网络</strong>。</p></li><li><p>通过网络链路和交换机移动数据有两种基本方法：<strong>分组交换</strong>和<strong>电路交换</strong></p><ul><li><p>分组交换：分组的定义是——为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块。在源与目的地之间，每个分组都通过<strong>通信链路</strong>和<strong>分组交换机</strong>（交换器主要有两类：<strong>路由器</strong>和<strong>链路层交换机</strong>）。每一个分组都以等于该链路最大传输速率的速度传输通过通信链路。</p><ul><li><p>存储转发传输：是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。</p><p>通过由N条速率均为R的链路组成的路径（也就是在源和目的地之间有N-1台路由器），从源到目的地发送一个分组，那么端到端的时延是：<br>$$<br>d_{端到端} = N\frac{L}{R}<br>$$</p></li><li><p>排队时延和分组丢失：对于每条相连的链路，该分组交换机具有一个<strong>输出缓存</strong>（或者是<strong>输出队列</strong>），用于存储路由器准备发往那条链路的分组。由于网络的拥塞程度的不同，<strong>排队时延</strong>也是会变化的。同时由于缓存空间的大小是有限的，一个到达的分组可能就会发现该缓存已被其他等待传输的分组充满，这就会导致<strong>分组丢失（丢包）</strong>——到达的分组或者已经排队的分组之一将被丢弃。</p></li><li><p>转发表和路由转发协议：每台路由器都有一个<strong>转发表</strong>，用于将目的地址（或目的地址的一部分）映射成为输出链路。而这些转发表的设置是<strong>由路由转发协议</strong>来自动设置。</p></li></ul></li><li><p>电路交换：电路交换与分组交换最大的区别就是<strong>在端系统间通信会话期间，是否预留了端系统间沿路径通信所需要的资源</strong>，在电路交换网络中是要预留的，在分组交换中则不会。在电路交换中也常常会使用到复用技术，主要有<strong>频分复用（FDM）</strong>和<strong>时分复用（TDM）</strong></p><ul><li>频分复用（FDM）：链路的频谱由跨越链路创建的所有连接共享，特别是，在连接期间链路为每条连接专用一个频段。</li><li>时分复用（TDM）：对于一条TDM链路，时间被划分为固定期间的帧，并且每个帧又被划分为固定数量的时隙。这些时隙专门由该连接单独使用，一个时隙可用于传输该连接的数据。对于TDM，一条电路的传输速率等于帧速率乘以一个时隙中的比特数量。</li></ul></li></ul><p>在当今电信网络中，分组交换和电路交换都是普遍采用的方式，但都是朝着分组交换的方向发展。原因是：电路交换不考虑需求，而预先分配了传输链路的使用，这就会使得已分配而并不需要的链路时间未被利用；相反，分组交换按需分配链路使用，链路传输能力将在所有需要在链路上传输分组的用户之间逐分组被共享。</p></li><li><p>因特网的网络结构</p><p>互联接入ISP的中心目标是使所有端系统能够彼此发送分组。</p><p><strong>网络结构1</strong>：用单一的全球传输ISP互联所有接入ISP。接入ISP被认为是客户，全球传输ISP被认为是提供商。</p><p><strong>网络结构2</strong>：由数十万接入ISP和多个全球传输ISP组成。要注意的是所有的全球传输ISP之间必须是互联的。</p><p><strong>网络结构3</strong>：这是一个多层等级结构，与今天的因特网粗略的相似。每个接入ISP向其连接的区域ISP支付费用，并且每个区域ISP向它连接的第一层ISP支付费用。</p><p><strong>网络结构4</strong>：是在等级化网络结构3的基础上增加<strong>存在点（PoP）</strong>、<strong>多宿</strong>、<strong>对等</strong>和<strong>因特网交换点（IXP）</strong>。PoP存在于等级结构的所有层次（底层等级除外）。一个PoP只是提供商网络中的一台或多台路由器群组。任何ISP（除了第一层ISP）都可以选择<strong>多宿</strong>，即可以与两个或更多提供商ISP连接。当一个ISP多宿时，即使它的提供商之一出现了故障，仍然能够继续发送和接收分组。客户ISP向提供商ISP支付的费用数额反映了它通过提供商交换的通信流量。为了减少这些开销，位于相同等级结构层次的邻近一对ISP能够<strong>对等</strong>，也就是能够直接将它们的网络连接到一起，使得两者的流量数据能够直接连接而不是通过上游的中间ISP传输。当两个ISP实现对等时，不进行任何的结算。所以说，网络结构4是由接入ISP、区域ISP、第一层ISP、PoP、多宿、对等和IXP组成。</p><p><strong>网络结构5</strong>：也就是今天的因特网。通过在网络结构4顶部增加<strong>内容提供商网络</strong>构建而成。通过创建自己的网络，内容提供商不仅能够减少向顶层ISP支付的费用，而且对其服务最终如何交付给端用户有了更多的控制。</p></li><li><p>分组交换网中的时延：<strong>节点处理时延</strong>、<strong>排队时延</strong>、<strong>传输时延</strong>、<strong>传播时延</strong>。</p><ul><li>节点处理时延：包括检查分组首部和决定该分组导向何处所需要的时间、检查比特级别的差错所需要的时间。</li><li>排队时延：一个特定分组的排队时延长度将取决于先期到达的正在排队等待向链路传输的分组数量。</li><li>传输时延：将所有分组的比特推向链路所需要的时间。</li><li>传播时延：在链路上传输分组所需要的时间。</li></ul><p>传输时延和传播时延的区别在于：前者是分组长度与链路传输速率的函数，后者是链路长度与链路传输速率的函数。</p><p>节点的总时延等于上述四个时延的和。</p></li><li><p>什么时候排队时延大？什么时候又不大？</p><p>取决于流量到达该队列的速率、链路的传输速率和到达流量的性质，即流量是周期性到达还是以突发形式到达。</p><p>设a表示分组到达队列的平均速率（单位是分组/秒，即pkt/s），R是队列的传输速率，即从队列中推出比特的速率（以bps为单位），同时假定所有分组都是由L比特组成。那么就能够得到<strong>流量强调</strong>的表达式：<br>$$<br>\frac{La}{R}<br>$$<br>流量强度是设计系统的一个重要指标——在流量工程中有一条金科定律：设计系统时流量强度不能大于1。并且，随着流量强度接近于1，平均排队时延迅速增加</p></li><li><p>关于<strong>丢包</strong>，从端系统的角度来看，似乎是一个分组已经传输到网络核心了，但它绝不会再从网络发送到目的地。并且，分组丢失的比例会随着流量强度增加而增加。基于此，一个节点的性能就不是根据时延来度量，而是根据丢包的概率来度量。</p><p>但是丢失的分组<strong>可能</strong>基于端到端的原则及逆行重传，以确保所有的数据最终从源传送到了目的地。</p></li><li><p>在今天因特网中对吞吐量的限制因素通常是接入网。</p></li><li><p>协议分层：为了给网络协议的设计提供一个结构，网络设计者以<strong>分层</strong>的方式组织协议以及实现这些协议的网络硬件和软件。协议分层具有<strong>概念化</strong>和<strong>结构化</strong>的优点。但也有一个潜在的缺点：一层可能冗余较低层的功能，同时某层的功能可能需要仅在其他某层才出现的信息，这违反了层次分离的目标。</p><p>因特网的协议栈由5个层次组成：物理层、链路层、网络层、运输层、应用层。</p><ul><li>应用层：是网络应用程序及它们的应用层协议存留的地方，协议包括HTTP、SMTP、FTP等。我们将位于应用层的信息分组称为<strong>报文</strong>。</li><li>运输层：在应用程序端点之间传送应用层报文。在因特网中有两种运输协议：TCP与UDP。<ul><li>TCP向它的应用程序提供了面向连接的服务，这种服务包括了应用层报文向目的地确保传递和流量控制（即发送方/接收方速率匹配）</li><li>UDP协议向它的应用程序提供无连接的服务。这是一种不提供不必要服务的服务，没有可靠性，没有流量控制，也没有拥塞控制。</li></ul></li><li>网络层：负责将称为数据报的网络层分组从一台主机移动到另一台主机。这一层包括了著名的网际协议IP，它定义了在数据报中的各个字段以及端系统和路由器如何做用于这些字段。也包括了路由选择协议等。</li><li>链路层：由链路层提供的服务取决于应用于该链路的特定链路层协议。链路层的分组被称为帧</li><li>物理层：将帧中的一个个比特从一个节点移动到下一个节点。这一层中的协议是链路相关的，并且进一步与该链路的实际传输媒体相关。</li></ul></li><li><p>OSI的七层模型：应用层、表示层、会话层、运输层、网络层、数据链路层、物理层。相较于五层结构，新增了表示层和会话层——表示层：使通信的应用程序能够解释交换数据的含义，这些服务包括数据压缩、数据加密、数据描述；会话层：提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。</p></li><li><p>数据的封装成帧：在发送主机端，一个<strong>应用层报文</strong>被传输给运输层，在运输层会被加上一个首部信息（设为$H_t$）成为<strong>运输层报文段</strong>；再被传输给网络层，在网络层加上一个首部信息（设为$H_n$）成为<strong>网络层数据报</strong>；再被传输给链路层，在链路层加上一个首部信息（设为$H_l$）成为<strong>链路层帧</strong>。最后这个帧被传输给物理层通过物理媒介传输。</p></li><li><p>病毒：一种需要某种形式的用户交互来感染用户设备的恶意软件。</p></li><li><p>蠕虫：一种无需任何明显用户交互就能进入设备的恶意软件。</p></li><li><p>拒绝服务攻击：也即是DoS攻击。它能够使得网络、主机或其他基础设施部分不能由合法用户使用。大多数因特网DoS攻击属于下面三种：</p><ul><li>弱点攻击：这涉及向一台目标主机上运行的易受攻击的应用程序或操作系统发送制作精细的报文。如果适当顺序的多个分组发送给一个易受攻击的应用程序或操作系统，该服务可能停止运行，或者更糟糕的是主机可能崩溃。</li><li>带宽洪泛：向目标主机发送大量的分组来造成目标的接入链路变得拥塞，以使合法的分组无法到达服务器。</li><li>连接洪泛：攻击者在目标主机中创建大量的半开或全开TCP连接，以使目标主机因这些伪造的连接而陷入困境，并停止接受合法的连接。</li></ul><p>目前最广泛地应该是DDoS，分布式拒绝服务攻击：攻击者痛过控制多个源并让每个源向目标猛烈发送流量。</p></li></ul><h1 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章 应用层"></a>第二章 应用层</h1><ul><li><p>研发网络应用程序的核心是写出能够运行在不同端系统和通过网络彼此通信的程序。</p></li><li><p>应用程序体系结构由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序。</p></li><li><p>现代应用程序中所使用的两种主流体系结构是：<strong>客户-服务器体系结构</strong>，<strong>对等（P2P）结构</strong></p><ul><li>客户-服务器体系结构：客户相互之间不直接通信，同时该服务具有固定的、周知的地址，这个地址被称为IP地址。这类的著名应用程序包括：Web、FTP、Telnet和电子邮件。</li><li>P2P体系结构：对位于数据中心的专用服务器有最小的依赖。它最好的特性是<strong>自扩展性</strong>。</li></ul></li><li><p>进程通信：一个进程可以被理解为是运行在端系统中的一个程序。当多个进程运行在相同的端系统上时，它们使用进程间通信机制相互通信。它的规则由端系统上的操作系统确定。在两个不同端系统上的进程，通过跨越计算机网络<strong>交换报文</strong>而相互通信：发送进程生成并向网络中发送报文，接收进程接受收这些报文并可能通过回送报文进行响应。</p><ul><li>客户和服务器进程：在每队通信进程中，将两个进程之一标识为客户，另一个进程标识为服务器。在客户-服务器体系结构中，客户和服务器是严格区分开的，但在P2P结构中，一个进程是既可以是客户又可以是服务器的。于是对二者的定义就为：<ul><li>客户：在一对进程之间的通信会话场景中，发起通信的进程被标识为客户。</li><li>服务器：在会话开始时等待联系的进程是服务器。</li></ul></li><li>进程通过一个称为<strong>套接字</strong>的软件接口向网络发送报文和从网络接收报文。套接字是同一台主机内<strong>应用层和运输层</strong>之间的接口，是建立网络应用程序的可编程接口，所以也被称为应用程序和网络之间的<strong>应用程序编程接口（API）</strong>。应用程序开发者对于运输层的控制仅限于：①选择运输层协议②也许能够设定几个运输层参数。</li><li>为了标识一个接收进程，需要定义两种信息：①主机的地址②在目的主机中指定接收进程的标识符。在因特网中主机由<strong>IP地址</strong>标识</li></ul></li><li><p>一个运输层协议能够为调用它的应用程序提供什么样的服务？从四个方面对应用程序服务要求进行分类：可靠数据传输、吞吐量、定时和安全性。</p><ul><li>可靠数据传输：如果一个协议提供了一端发送的数据正确、完全地交付给该应用程序的另一端的数据交付服务，就认为提供了可靠数据传输。当一个运输层协议无法提供可靠数据传输时，由发送进程发送的某些数据就可能到达不了接收进程，但这或许能被<strong>容忍丢失的应用</strong>所接受，例如一些播放音视频的软件，丢失的数据对它们会产生小干扰，但不会出现致命伤。</li><li>吞吐量：在这种服务下，应该程序能够请求一定值的比特/秒的确保吞吐量，并且运输协议能够确保可用吞吐量总是至少为这个值。具有吞吐量要求的应用程序被称为<strong>带宽敏感的应用</strong>，<strong>弹性应用</strong>能够根据当是可用的带宽或多或少地利用可供使用的吞吐量。</li><li>定时：这种服务对交互式实时应用程序有吸引力，比如因特网电话、电话会议、网络游戏等，这些应用为了有效性而要求数据交付有严格的时间限制。但对于非实时的应用，较低的时延总比较高的时延好，而且对端到端的时延没有严格地约束。</li><li>安全性：是否对传输的数据进行加密处理。</li></ul></li><li><p>TCP服务模型：包括面向连接的服务和可靠数据传输服务：</p><ul><li>面向连接的服务：在应用层数据报文开始流动之前，TCP会让客户和服务器进行”握手“（握手阶段），互相交换运输层控制信息。之后一个<strong>TCP连接</strong>就在两个进程的套接字之间建立了。这条连接的<strong>全双工的（即连接双方的进程可以在此连接上同时进行报文收发）</strong>。当应用程序结束报文发送时，该连接必须拆除。</li><li>可靠的数据传送服务：通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。在字节被套接字交付的过程中，是没有字节的丢失和冗余的。</li><li>此外还具有拥塞控制机制。这种服务不见得能够为通信进程带来直接的好处，但能为因特网带来整体好处。</li></ul></li><li><p>UDP服务模型：是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。因为UDP是无连接的，所以在两个进程通信前没有握手过程。同时它提供的也是不可靠数据传输服务，也就是当发送进程将报文发送进UDP套接字时，UDP协议并不保证该报文将到达接收进程。UDP也是没有拥塞控制的，所以可以用它选定的任何速率向其下层（即网络层）注入数据。</p></li><li><p>应用层协议：这些协议定义了运行在不同端系统上的应用程序进程是如何相互传递报文的。特别是定义了：</p><ul><li>交换的报文类型：例如请求报文和响应报文。</li><li>各种报文类型的语法：例如报文中的各个字段及这些字段是如何描述的</li><li>字段的语义</li><li>确定一个进程何时以及如何发送报文，对报文进行响应的规则。</li></ul></li><li><p>应用层协议只是网络应用的一部分。</p></li><li><p>Web与HTTP：Web的应用层协议就是<strong>超文本传输协议HTTP</strong>，它是Web的核心。HTTP由两个程序实现：一个客户程序和一个服务器程序。它们俩运行在不同的端系统中，通过交换HTTP报文进行对话。它定义了这些报文的结构以及客户和服务器进行报文交换的方式。</p><ul><li>HTTP定义了Web客户向Web服务器请求Web页面的方式，以及服务器向客户传送Web页面的方式，其基本方式是：当用户请求一个Web页面时（比如点击一个链接），浏览器向服务器发出对该页面所包含对象的HTTP请求报文，服务器接收到请求并用包含这些对象的HTTP响应报文进行响应。</li><li>HTTP是将TCP作为它的支撑运输协议：HTTP客户首先发起一个与服务器的TCP连接，一旦连接建立起，该浏览器和服务器进程就可以通过套接字接口访问TCP</li><li>HTTP是一个<strong>无状态协议</strong>，所以HTTP服务器并不保存关于客户的任何信息。</li><li>Web是使用了客户-服务器应用程序体系结构，Web服务器总是打开的，具有一个固定的IP地址，且它服务于可能来自数以百万计的不同浏览器请求。</li></ul></li><li><p>HTTP与客户如何解释一个Web页面毫无关系，HTTP规范仅定义了在HTTP客户程序与HTTP服务器程序之间的通信协议。</p></li><li><p>往返时间RTT：指一个短分组从客户到服务器然后再返回客户所花费的时间。它包括了分组传播时延、分组在中间路由器和交换机上的排队时延，分组处理时延。</p></li><li><p>采用非持续连接的HTTP：每一个请求/响应对是经一个单独的TCP连接发送。但有一些缺点：①必须为每一个请求的对象建立和维护一个全新的连接。对于每一个这样的连接，在客户和服务器中都要分配TCP缓冲区和TCP变量，这就会给Web服务器带来严重的负担；②每一个对象会经受两倍RTT的交付时延，即一个RTT用于创建TCP，另一个RTT用于请求和接收一个对象。</p></li><li><p>采用持续连接的HTTP：所有的请求及其响应经相同的TCP连接发送。与非持续连接的HTTP不同的是，持续连接下，服务器在发送响应后保持该TCP连接的打开。一个完整的Web页面可以用单个持续TCP连接进行传送；位于同一台服务器的多个Web页面在从该服务器发送给同一个客户时，也可以在单个持续TCP连接上进行。</p><p>在这种情况下，对对象的请求可以一个接一个的发出，而不需要等待对未决请求的回答。在实际中，若一条连接经过一定的时间间隔仍未被使用，那么HTTP服务器仍然会关闭这条连接。</p></li><li><p>HTTP的报文格式：HTTP的主要报文有两种——请求报文和响应报文：</p><ul><li><p><strong>请求报文</strong>：请求报文的第一行叫作<strong>请求行</strong>，其后继的行叫作<strong>首部行</strong>（首部行所提供的信息是Web代理高速缓存所要求的）</p><p>①请求行有三个字段：方法字段、URL字段、HTTP版本字段</p><ul><li><strong>方法字段</strong>：有五种取值——GET、POST、HEAD（服务器不会返回请求对象）、PUT（允许用户上传对象到指定的Web服务器上的指定路径）、DELETE（允许用户或者应用程序删除Web服务器上的对象）</li><li><strong>URL字段</strong>：请求对象的标识，也即虚拟目录部分</li><li><strong>HTTP版本字段</strong>：由其自解释得到</li></ul><p>②首部行包括但不限于：</p><ul><li><strong>Host</strong>指明了对象所在的主机；</li><li><strong>Connection</strong>指明服务器是否要在发送完被请求的对象后就关闭这条连接；</li><li><strong>User-agent</strong>指明用户代理，即向服务器发送请求的浏览器类型；</li><li><strong>Accept-language</strong>告知服务器用户代理能够处理的自然语言集。</li></ul><p>③在首部行后可能还有一个“实体体（entity body）”，只有当请求行的方法字段为POST时，实体体才会有内容。当使用POST时，表明用户在提交表单，最明显的就是使用搜索引擎进行搜索，此时用户提交的表单的值，也就是搜素值就在实体体中。</p><p>实际上在使用GET方法时，在URL中就是包括了输入的数据的。例如：</p><p>一个表单使用GET方法，它有两个字段，分别填写的是“monkeys”和“bananas”，那么URL的结构就为”<a href="http://www.somesite.com/animalsearch?monkey&amp;bananas&quot;%EF%BC%88%E8%81%94%E6%83%B3%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB%E4%B8%AD%E6%89%80%E8%A7%81%E5%88%B0%E7%9A%84URL%EF%BC%89">www.somesite.com/animalsearch?monkey&amp;bananas&quot;（联想日常生活中所见到的URL）</a></p></li><li><p><strong>响应报文</strong>：由三个部分组成①初始<strong>状态行</strong>（与请求报文的初始行）②<strong>首部行</strong>③<strong>实体体</strong>（这是报文的主要部分，包含了所请求的对象本身），具体看看首部行：</p><p>①首部行包括但不限于：</p><ul><li><strong>Connection</strong>：与请求报文的Connection相同</li><li><strong>Date</strong>指明服务器产生并发送该响应报文的日期和时间，但要注意的是这个时间不是指对象创建或者最后修改的时间，而是服务器从它的文件系统中检索到该对象，将该对象插入响应报文，并发送该响应报文的时间</li><li><strong>Server</strong>：类似于请求报文中的User-agent</li><li><strong>Last-Modified</strong>：指示了对象创建或者最后修改的日期和时间</li><li><strong>Content-Length</strong>：指示了被发送对象中的字节数</li><li><strong>Content-Type</strong>：指示了实体体中的对象的文本类型例如HTML</li></ul><p>②状态行的状态码：状态码及其相应的短语指示了请求的结果。具体短语有：</p><ul><li><strong>200 OK</strong>：请求成功，信息在返回的响应报文中</li><li><strong>300 Moved Permanently</strong>：请求的对象已经被永久转移了，新的URL定义在响应报文的<strong>Location</strong>首部行中。客户软件将自动获取新的URL</li><li><strong>400 Bad Request</strong>：一个通用差错代码，指示该请求不能被服务器理解</li><li><strong>404 Not Found</strong>：被请求的文档不在服务器上</li><li><strong>505 HTTP Version Not Support</strong>：服务器不支持请求报文使用的HTTP协议版本</li></ul></li></ul></li><li><p>cookie：用户和服务器的交互。一个HTTP服务器是无状态的，但为了能够使Web站点识别用户（原因可能是：①服务器希望限制服务访问②服务器希望将内容与用户身份联系起来）cookie有四个组件：</p><ul><li>在HTTP响应报文中的一个cookie首部行</li><li>在HTTP请求报文中的一个cookie首部行</li><li>在用户端系统中保留有一个cookie文件，并由用户的浏览器进行管理</li><li>位于Web站点的一个后端数据库</li></ul><p>服务器可以通过cookie给用户设定的编码获取用户在Web站点的行为。</p></li><li><p>Web缓存：Web缓存器也叫<strong>代理服务器</strong>。它是能够代表初始Web服务器来满足HTTP请求的网络实体。Web缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。Web缓存器既是服务器也是客户——当浏览器向Web缓存器创建一个TCP连接并发送一个HTTP请求报文时，若Web缓存器中有对象副本，就发送HTTP响应报文，此时是一个服务器；若是没有，则继续向初始服务器发送HTTP请求报文，此时是客户。</p><p>部署Web缓存器的原因：</p><ul><li>可以大大减少对客户请求的响应时间</li><li>能够大大减少一个机构的接入链路到因特网的通信量</li><li>能够大大减低因特网上的Web流量</li></ul></li><li><p>电子邮件系统：有3个主要的组成部分——<strong>用户代理</strong>、<strong>邮件服务器</strong>、<strong>简单邮件传输协议</strong></p><p>主要用到的应用层协议是SMTP，与TCP一样，采用可靠数据传输服务，同时它也有两个部分：</p><ul><li>运行在发送方邮件服务器的客户端和运行在接收方邮件服务器的服务器端。</li></ul></li><li><p>关于SMTP：它是因特网电子邮件的核心，要注意的是它不通过中间邮件服务器发送邮件，即使这两个服务器相距再远，也是直接建立TCP连接。</p></li><li><p>HTTP与SMTP的对比：①都用于一台主机向另一台主机传送文件：HTTP是从Web服务器向Web客户端传送文件，SMTP是从一个邮件服务器向另一个邮件服务器传送文件；②当进行文件传输时，持续的HTTP与SMTP都是使用持续连接；③HTTP主要是一个<strong>拉协议</strong>，即在某时刻，用户是使用HTTP从一个Web服务器上拉取某些人在这个服务器上装载的信息。而SMTP是一个<strong>推协议</strong>，即发送邮件服务器把文件推向接收邮件服务器。前者的TCP连接是由想接受文件的机器发起的，后者的TCP连接是由要发送该文件的机器发起的。④SMTP要求每个报文才用7比特的ASCII码格式，而HTTP则没有这个要求；⑤HTTP是将每个对象封装到它自己的HTTP响应报文中，而SMTP则把所有报文对象放在一个报文中。</p></li><li><p>邮件报文格式：如同HTTP协议，每个首部行包含了可读文本——由关键词后跟冒号及其值组成。一些关键词是必须的，比如**From:<strong>，</strong>To:<strong>，</strong>Subject:**，另一些是必选的：</p></li><li><p>接收方是如何通过本地的用户代理去获取他的某ISP的邮件服务器上的邮件？</p><p>首先我们要知道的是接收方是无法通过SMTP来得到报文的，因为取报文是一个拉操作，SMTP是一个推协议，执行的推操作，所以就需要除了HTTP以外的新的、能够执行拉操作的协议：<strong>第三版的邮件协议（POP3）</strong>、<strong>因特网邮件访问协议（IMAP）</strong></p><ul><li><p>POP3</p><p>这是一个非常简单的协议，也就造成其功能相当有限。它按照三个阶段进行工作：特许、事务处理、更新。</p><ul><li><p>第一阶段，也即特许阶段，用户代理以明文的形式发送用户名和口令以鉴别用户。这一阶段主要有两个命令：user<user name>和pass <password>，</password></user></p></li><li><p>第二阶段，也即事务处理阶段，用户代理取回报文，同时用户代理还能对报文做删除标记、取消报文删除标记、获取邮件的统计信息的操作。这一阶段服务器会对用户的每个命令作出回答，一般是两种：+OK——被服务器用来指示前面的命令是正常的；-ERR——被服务器用来指示前面的命令出现某些差错。</p><p>这个阶段的具体过程被用户在用户代理中配置为了两种：下载并删除和下载并保留。</p><ul><li>使用下载并删除的方式：用户代理会发出list、retr、dele命令。用户代理首先请求邮件服务器列出所有存储的报文的长度，再从邮件服务器取回并删除每封邮件。</li><li>使用下载并保留的方式：这是为了解决下载并删除方式中客户不能使用不同的终端来进行邮件接收的问题。在下载并保留方式中，用户代理下载某邮件后，该邮件仍然保存在邮件服务器上，这样客户就能使用不同的终端重新读取这些邮件。</li></ul></li><li><p>第三阶段，也即更新阶段，它出现在客户发出quit命令后，目的是结束该POP3会话，这个时候该邮件服务器也要删除那些被标记为删除的报文。</p></li></ul><p>在POP3协议中，POP3服务器并不会在POP3会话过程中携带状态信息，也是因此大大简化了POP3服务的实现。</p></li><li><p>IMAP</p><p>是为了解决将报文存储在本地来移动麻烦的问题。在IMAP协议下，客户可以通过客户端直接对服务器上的邮件进行操作。它为客户提供了创建文件夹以及将邮件从一个文件夹移动到另一个文件夹的命令。同时还提供了在远程文件夹中查询邮件的命令。与POP3不同的是，IMAP服务器维护了IMAP绘画的用户状态信息。</p><p>此外，IMAP还允许用户代理仅仅去获取报文的一部分。</p></li><li><p>HTTP</p><p>使用HTTP进行电子邮件的收发时，用户代理就是普通的浏览器。使用基于Web的电子邮件时，要注意的是，从发送方到它的邮件服务器是通过HTTP建立的连接，而不是之前的SMTP.</p></li></ul></li><li><p>DNS：识别主机有两种方式——通过主机名或者IP地址。对于路由器而言，使用的是定长的、有着层次结构的IP地址；对于我们而言，则是喜欢使用主机名。为了能够在主机名和IP地址间建立一种映射关系，于是就有了<strong>域名系统（DNS）</strong></p><p>DNS是：①一个由分层的DNS服务器实现的<strong>分布式数据库</strong>，②一个使得主机能够查询分布式数据库的应用层协议。DNS服务器通常是运行在能够运行BIND的UNIX机器上的，并且DNS协议是运行在UDP上的，使用的是53号端口。</p><p>DNS通常是由其他应用层协议所使用（要注意，DNS只是个系统，而非协议），包括HTTP、SMTP、FTP等，就是为了将用户提供的主机名解析为IP地址。这是DNS系统提供的最主要的服务，此外它还提供服务有：</p><ul><li>主机别名：应用程序可以调用DNS来获得主机别名对应的规范主机名以及主机的IP地址</li><li>邮件服务器别名：同主机别名一样</li><li>负载分配：用于在冗余的服务器之间进行负载分配。繁忙的站点被冗余分布在多台服务器上，每台服务器均运行在不同的端系统上，每个都有着不同的IP地址，也就是说一个IP地址集合对应着同一个规范主机名</li></ul></li><li><p>关于DNS在互联网上的分布式数据库的实现：</p><ul><li><p><strong>分布式、层次数据库</strong>：DNS使用了大量的DNS服务器，并以层次方式组织分布在全世界范围内。这些服务器分为三类：<strong>根DNS服务器</strong>、<strong>顶级域（TLD）DNS服务器</strong>、<strong>权威DNS服务器</strong>。在《自顶而下》中，以<a href="http://www.amazon.com为例，DNS解析它的过程被分为：">www.amazon.com为例，DNS解析它的过程被分为：</a></p><p>①客户先与根服务器之一联系，将返回顶级域名com的TLD服务器的IP地址</p><p>②根据返回的IP地址，与对应的TLD服务器中的一个联系，它将为amazon.com返回权威服务器的IP地址</p><p>③最后于amazon.com的权威服务器之一联系，它为主机名<a href="http://www.amazon.com返回其ip地址/">www.amazon.com返回其IP地址</a></p><ul><li>根DNS服务器：DNS中最高级别的域名服务器，返回的是TLD服务器的IP地址。</li><li>顶级域（TLD）DNS服务器：对每个通用顶级域（例如com、org、net、edu和gov）和所有国家及地区顶级域（例如uk、fr、ca和jp），都有TLD服务器或服务器集群。返回的是权威DNS服务器的IP地址。</li><li>权威DNS服务器：多数大学和大公司实现和维护它们自己基本和辅助（备份）的权威DNS服务器。一个组织的权威DNS服务器收藏的是，在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的DNS记录，这些记录会将这些主机的名字映射为IP地址。</li></ul><p>要注意，DNS对域名进行解析，是从外到内的逐层进行解析。还是以<a href="http://www.amazon.com为例,先在根域名服务器解析com,再在tld服务器解析amazon.com,最后在权威服务器中解析www.amazon.com.在这个解析过程中,一共有6份报文——3份查询报文和3份回答报文./">www.amazon.com为例，先在根域名服务器解析com，再在TLD服务器解析amazon.com，最后在权威服务器中解析www.amazon.com。在这个解析过程中，一共有6份报文——3份查询报文和3份回答报文。</a></p><p>3份查询报文分别是请求主机向根DNS服务器、向TLD DNS服务器、向权威DNS服务器发出的查询报文</p><p>3份回答报文分别是根DNS服务器、TLD DNS服务器、权威DNS服务器分别向请求主机发出的回答报文</p><p>还有一种服务器是<strong>本地DNS服务器（也叫默认名字服务器）</strong>，但严格来说它并不属于DNS的层次结构。每个ISP都有一个本地DNS服务器。每一次请求主机向外发送查询报文时，都是先向本地DNS服务器发送查询报文，并由本地DNS服务器发送/接收其他三种DNS服务器的报文。</p><p>所以说上面那个例子实际上是8份报文——4份查询报文和4份回答报文。多的是请求主机与本地DNS服务器间的报文发送和接受。</p></li><li><p><strong>查询方式</strong>：<strong>递归查询</strong>和<strong>迭代查询</strong>——从请求主机到本地DNS服务器的查询是递归查询，其余的查询时迭代查询。</p></li><li><p><strong>DNS缓存：</strong>为了改善时延性能并减少在因特网上到处传输的DNS报文数量，DNS广泛使用了缓存技术。其原理为：在一个请求链中，当某DNS服务器接收一个DNS回答时，它能将映射缓存在本地存储器中。</p><p>这样做的好处就是在一段时间内能够为其他主机提供所要求的IP地址，即使它不是该主机的权威服务器。但要注意的是，是在一段时间内，DNS服务器会在一段时间后（通常时设置的两天）丢弃缓存的信息。</p></li></ul></li><li><p>为什么DNS是基于UDP而不是TCP?</p><p>衡量计算机通信快慢的指标是“响应时间”，即从用户发出通信指令开始，到用户看完完整页面为止所流逝的时间。</p><p>以浏览器为例，响应时间分为三部分：响应时间 = DNS域名解析时间 + TCP连接时间 + HTTP交易时间</p><p>TCP连接时间时固定的三次握手时间；HTTP交易时间是基于Request/Response，很难有提升时间；所以网络工程师就将时间上的优化放在了DNS的域名解析上。</p><p>①若DNS基于TCP，那么解析时间公式就为：</p><p>DNS域名解析时间 = TCP连接时间 + DNS交易时间</p><p>②若DNS基于UDP，那么解析时间公式就为：</p><p>DNS域名解析时间 = DNS交易时间</p><p>从表达式上就能看出基于UDP能够节约一定的连接时间，毕竟UDP是面向无连接的。</p></li><li><p>DNS记录：共同实现DNS分布式数据库的所有DNS服务器存储了<strong>资源记录（RR）</strong>,它提供了主机到IP地址的映射。资源记录是一个包含了如下字段的4元组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">(Name, Value, Type, TTL)<br></code></pre></td></tr></table></figure><p>Type一共有四种取值：</p><ul><li>Type = A：表示Value是名为Name的主机的IP地址。这个记录提供了标准的主机名到IP地址的映射。</li><li>Type = NS：表明Name是一个域，而Value是一个知道如何获得该域中主机IP地址的权威DNS服务器的主机名。这个记录用来沿着查询链来路由DNS查询。</li><li>Type = CNAME：表明Value是别名为Name的主机对应的规范主机名。这个记录能够向查询的主机提供一个主机名对应的规范主机名。</li><li>Type = MX：表明Value是个别名为Name的邮件服务器的规范主机名。这只是获得邮件服务器的别名。</li></ul></li><li><p>DNS报文具体格式：DNS两种报文报文有着相同的格式。</p><ul><li><strong>前12个字节是首部区域</strong>：第一个字段是<strong>标识符</strong>，占16比特的数，用于标识该查询，这个标识符会被复制到对该查询的回答报文中；第二字段是<strong>标志</strong>，占1比特的数，用于指明该报文是查询报文（0）还是回答报文（1）；第三字段是<strong>问题数</strong>；第四字段是<strong>回答RR数</strong>；第五字段是<strong>权威RR数</strong>；第六字段是<strong>附加RR数</strong></li><li><strong>问题区域</strong>：包含正在进行的查询信息，包括：①名字字段，包含正在被查询的主机；②类型字段，指出有关该名字的正在被询问的问题类型</li><li><strong>回答区域</strong>：包含了对最初请求的名字的资源记录。在回答报文的回答区域中可以包含多条RR，因此一个主机名能够有多个IP地址</li><li><strong>权威区域</strong>：包含了其他权威服务器的记录</li><li><strong>附加区域</strong>：包含的是其他有帮助的记录</li></ul></li><li><p>P2P：能够实现从单一服务器向大量主机（称为对等方）分发一个大文件。在《自顶而下》中，通过假定在一个小时内一个对等方能够传输整个文件，并且该服务器的传输速率是对等方上载速率的10倍，以及对等方的下载速率被设置得足够大，就发现：</p><p>①对于客户-服务器体系结构，随着对等方数量的增加，发布时间呈线性增长并没有界</p><p>②对于P2P体系结构，最小分发时间不仅总是小于客户-服务器体系结构的分发时间，并且对于任意的对等方数量N，总是小于1小时</p><p>所以说，具有P2P体系结构的应用程序能够是自扩展的。这种扩展性的直接成因是对等方除了是比特的消费者外还是他们的重新分发者。</p></li><li><p>对流式视频最重要的性能度量是<strong>平均端到端吞吐量</strong>。通常压缩的因特网视频的比特率范围通常从用于低质量视频的100kbps到用于流式高分辨率电影的超过3Mbps。所以为了提供连续不断的布局，网络必须为流式应用提供平均吞吐量，这个流式应用至少与压缩视频的比特率一样大。</p></li><li><p>CDN（内容分发网）：为了应对向分布于全世界的用户分发巨量视频数据而提出的网络。CDN通常采用两种不同的服务器安置原则：</p><ul><li><strong>深入</strong>：通过在遍及全球的接入ISP中部署服务器集群来<strong>深入</strong>到ISP的接入网中。其目标是靠近端用户，通过减少端用户和CDN集群之间链路和路由器的数量，从而改善用户感受的时延和吞吐量。</li><li><strong>邀请做客</strong>：通过在少量关键位置建造大量集群来<strong>邀请</strong>到ISP中做客。不是将集群放在接入ISP中，这些CDN通常将它们集群放置在因特网交换点（IXP）。</li></ul><p>两者的比较：前者的高度分布式设计，给维护和管理集群的任务带来了极大的挑战；后者通常产生较低的维护和管理开销，代价就是对端用户的较高时延和较低吞吐量。</p></li><li><p>CDN是怎么工作的：<strong>理论上</strong>，一旦CDN的集群准备就绪，它就可以跨集群复制内容，同时CDN也不会将每个视频的副本放置在每个集群中。<strong>但实际上</strong>，许多CDN并没有将视频推入它们的集群，而是使用一种简单的<strong>拉策略</strong>：如果客户向一个未存储该视频的集群请求某视频，则该集群检索该视频（从某中心仓库或者从另一个集群），向客户流式传输视频时的同时在本地存储一个副本。这很类似于因特网缓存，当某集群存储器变满时，它删除不经常请求的视频。</p></li><li><p>CDN部署的核心是<strong>集群选择策略</strong>，即动态地将客户定向到CDN中的某个服务器集群或数据中心的机制。</p></li><li><p>开发者创建一个网络应用时，其主要任务就是编写客户程序和服务器程序的代码。这就是套接字编程。</p><ul><li><p>UDP套接字编程</p><p>在发送进程能够将数据分组推出套接字之门之前，当使用UDP时，必须先将目的地址附在该分组上面。在该分组传过发送方的套接字之后，因特网将使用该目的地址通过因特网为该分组选路到接收进程的套接字。当分组到达接受套接字时，接收进程将通过该套接字取回分组，然后检查分组的内容并采取适当的动作。</p><p>对于这个附着在分组上的目的地址，它包括了目的主机的IP地址、目的地套接字的端口号。</p><p>这里介绍C++中的socket函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-keyword">int</span> domain, <span class="hljs-keyword">int</span> type, <span class="hljs-keyword">int</span> protocol)</span></span><br></code></pre></td></tr></table></figure><p>函数的使用要用的头文件有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li><p>参数domain：表示要使用的协议簇，协议簇定义在第二个头文件中，包括了：</p><table><thead><tr><th align="center">代码</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><strong>AF_INET6</strong></td><td align="center"><strong>IPv6网络通信</strong></td></tr><tr><td align="center"><strong>AF_PACKET</strong></td><td align="center"><strong>链路层通信</strong></td></tr><tr><td align="center"><strong>AF_UNIX, AF_LOCAL</strong></td><td align="center"><strong>本地通信</strong></td></tr><tr><td align="center"><strong>AF_INET</strong></td><td align="center"><strong>IPv4网络通信</strong></td></tr></tbody></table></li><li><p>参数type：表示套接字的类型，包括了：</p><table><thead><tr><th align="center">代码</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><strong>SOCK_DGRAM</strong></td><td align="center"><strong>UDP数据报套接字</strong></td></tr><tr><td align="center"><strong>SOCK_RAW</strong></td><td align="center"><strong>原始套接字</strong></td></tr><tr><td align="center"><strong>SOCK_SEQPACKET</strong></td><td align="center"><strong>有序分组套接字</strong></td></tr><tr><td align="center"><strong>SOCK_STREAM</strong></td><td align="center"><strong>TCP字节流套接字</strong></td></tr></tbody></table></li><li><p>参数protocol：选择传输协议的类型</p><table><thead><tr><th align="center">代码</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><strong>IPPTOTO_UDP</strong></td><td align="center"><strong>UDP传输协议</strong></td></tr><tr><td align="center"><strong>IPPTOTO_SCTP</strong></td><td align="center"><strong>STCP传输协议</strong></td></tr><tr><td align="center"><strong>IPPTOTO_TIPCTCP</strong></td><td align="center"><strong>TIPC传输协议</strong></td></tr><tr><td align="center"><strong>IPPROTO_TCP</strong></td><td align="center"><strong>TCP传输协议</strong></td></tr></tbody></table></li><li><p><strong>客户端：</strong></p><p>①创建套接字描述符（使用socket()方法）</p><p>②设置服务器的IP地址和端口号（使用htons()方法，转换为网络字节序的格式）</p><p>③向套接字描述符写入请求并发送给服务器（使用sendto()方法）</p><p>④从套接字描述符读取来自服务器的应答（使用recvfrom()方法）</p><p>⑤关闭套接字描述符（使用close()方法）</p></li><li><p><strong>服务端：</strong></p><p>①创建套接字描述符（使用socket()方法）</p><p>②设置服务器的IP地址和端口号（使用htons()方法，转换为网络字节序的格式）</p><p>③将套接字描述符绑定到服务器地址（使用bind()方法）</p><p>④从套接字描述符读取来自客户端的请求并取得客户端的地址（使用recvfrom()方法）<br>⑤向套接字描述符写入应答并发送给客户端（使用sendto()方法）<br>⑥回到第4步等待读取下一个来自客户端的请求</p></li></ul><p>客户端和服务端的代码示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1、UDPClient.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span>   </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;winsock2.h&gt;</span><span class="hljs-comment">// WINSOCK API的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;WS2tcpip.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib,<span class="hljs-meta-string">&quot;ws2_32.lib&quot;</span>)<span class="hljs-comment">// WINSOCK API连接库文件</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-comment">// 无论是UDP还是TCP，在进行套接字描述符的创建前，都要先进行winsock库的连接</span><br>    WORD socketVersion = <span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">// 调用Winsock2.2版本</span><br>WSADATA wsaData;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(socketVersion, &amp;wsaData) != <span class="hljs-number">0</span>)&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;WSAStartup failed:&quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; endl;<br>&#125;<span class="hljs-comment">// 加载套接字库</span><br><br>SOCKET sclient = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP); <span class="hljs-comment">//客户端套接字</span><br><br>sockaddr_in sin;<br>sin.sin_family = AF_INET;<br>sin.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">8888</span>);<br><span class="hljs-comment">/*sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);*/</span><br><span class="hljs-built_in">inet_pton</span>(AF_INET, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, (<span class="hljs-keyword">void</span>*)&amp;sin.sin_addr.S_un.S_addr);<br><br><span class="hljs-keyword">int</span> len = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(sin);<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* sendData = <span class="hljs-string">&quot;来自客户端的数据包.\n&quot;</span>;<br><span class="hljs-built_in">sendto</span>(sclient, sendData, <span class="hljs-built_in">strlen</span>(sendData), <span class="hljs-number">0</span>, (sockaddr*)&amp;sin, len);<br><br><span class="hljs-keyword">char</span> recvData[<span class="hljs-number">255</span>];<br><span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">recvfrom</span>(sclient, recvData, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, (sockaddr*)&amp;sin, &amp;len);<br><span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span>)&#123;<br>recvData[ret] = <span class="hljs-number">0x00</span>;<br><span class="hljs-built_in">printf</span>(recvData);<br>&#125;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-built_in">closesocket</span>(sclient);<br><span class="hljs-built_in">WSACleanup</span>();<span class="hljs-comment">//这两句话就是关闭socket连接</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">// UDPServer.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span>   </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;winsock2.h&gt;</span>   </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;WS2tcpip.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib,<span class="hljs-meta-string">&quot;ws2_32.lib&quot;</span>)    </span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>WSADATA wsaData;<br>WORD sockVersion = <span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(sockVersion, &amp;wsaData) != <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>SOCKET serSocket = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP); <span class="hljs-comment">//服务端套接字</span><br><span class="hljs-keyword">if</span> (serSocket == INVALID_SOCKET)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;socket error !&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>sockaddr_in serAddr;<br>serAddr.sin_family = AF_INET;<br>serAddr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">8888</span>);<br>serAddr.sin_addr.S_un.S_addr = INADDR_ANY;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(serSocket, (sockaddr*)&amp;serAddr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(serAddr)) == SOCKET_ERROR)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bind error !&quot;</span>);<br><span class="hljs-built_in">closesocket</span>(serSocket);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>sockaddr_in remoteAddr;<br><span class="hljs-keyword">int</span> nAddrLen = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(remoteAddr);<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-keyword">char</span> recvData[<span class="hljs-number">255</span>];<br><span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">recvfrom</span>(serSocket, recvData, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, (sockaddr*)&amp;remoteAddr, &amp;nAddrLen);<br><span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span>)&#123;<br>recvData[ret] = <span class="hljs-number">0x00</span>;<br><span class="hljs-keyword">char</span> sendBuf[<span class="hljs-number">20</span>] = &#123; <span class="hljs-string">&#x27;\0&#x27;</span> &#125;;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;接受到一个连接：%s \r\n&quot;</span>, <span class="hljs-built_in">inet_ntop</span>(AF_INET, (<span class="hljs-keyword">void</span>*)&amp;remoteAddr.sin_addr, sendBuf, <span class="hljs-number">16</span>));<br><span class="hljs-built_in">printf</span>(recvData);<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* sendData = <span class="hljs-string">&quot;UDP测试\n&quot;</span>;<br><span class="hljs-built_in">sendto</span>(serSocket, sendData, <span class="hljs-built_in">strlen</span>(sendData), <span class="hljs-number">0</span>, (sockaddr*)&amp;remoteAddr, nAddrLen);<br><br>&#125;<br><span class="hljs-built_in">closesocket</span>(serSocket);<br><span class="hljs-built_in">WSACleanup</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>TCP套接字编程</p><p>TCP编程与UDP最大的不同就是客户与服务器之间要先进行握手和创建一个连接。同时与UDP一样，TCP服务器在客户试图发起接触之前必须作为一个进程运行起来。</p><p>随着服务器进程的运行，客户进程能够向服务器发起一个TCP连接。这是由客户程序通过创建一个TCP套接字完成的。当客户生成其TCP套接字时，它指定了服务器中的欢迎套接字的地址，即服务器主机的IP地址及其套接字的端口号。生成套接字后，该客户发起了一个三次握手并创建与服务器的一个TCP连接。发生在运输层的三次握手，对于客户和服务器是完全透明的。</p><p>从应用程序的观点来看，客户套接字和服务器连接套接字直接通过一根管道连接，客户进程能够向它的套接字发送任意字节，并且TCP保证服务器进程能够按发送的顺序接收每个字节。</p><p>具体编程为：</p><ul><li><p><strong>客户端</strong></p><p>①创建套接字描述符（使用socket()方法）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">SOCKET sclient = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);<br></code></pre></td></tr></table></figure><p>②设置服务器的IP地址和端口号（需要转换为网络字节序的格式）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">sockaddr_in sin;<br>sin.sin_family = AF_INET;<br>sin.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">8888</span>);<span class="hljs-comment">// 设置端口号，转换为网络字节序的格式</span><br><span class="hljs-comment">/*sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);*/</span><br><span class="hljs-built_in">inet_pton</span>(AF_INET, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, (<span class="hljs-keyword">void</span>*)&amp;sin.sin_addr.S_un.S_addr);<span class="hljs-comment">// 设置IP地址</span><br></code></pre></td></tr></table></figure><p>③请求建立到服务器的TCP连接并阻塞，直到连接成功建立（使用connect()方法）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(sclient, (sockaddr *)&amp;serAddr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(serAddr)) == SOCKET_ERROR)&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;connect error !&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">closesocket</span>(sclient);<span class="hljs-comment">// 如果连接失败，就关闭套接字</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>④向套接字描述符写入请求（使用send()函数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;输入你想传输的数据： \n&quot;</span>;<br>string data;<br>cin &gt;&gt; data;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * sendData2;<br>sendData2 = data.<span class="hljs-built_in">c_str</span>(); <span class="hljs-comment">//string转const char*</span><br><span class="hljs-built_in">send</span>(sclient, sendData2, <span class="hljs-built_in">strlen</span>(sendData2), <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>⑤从套接字描述符读取来自服务器的应答（使用revc()函数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">char</span> recData[<span class="hljs-number">255</span>];<span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">recv</span>(sclient, recData, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span>)&#123;recData[ret] = <span class="hljs-number">0x00</span>;<span class="hljs-built_in">printf</span>(recData);&#125;<br></code></pre></td></tr></table></figure><p>⑥关闭套接字描述符（使用close()方法）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">closesocket</span>(sclient);<br></code></pre></td></tr></table></figure></li><li><p><strong>服务端</strong></p><p>①创建套接字描述符（使用socket()方法）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">SOCKET slisten = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);<br></code></pre></td></tr></table></figure><p>②设置服务器的IP地址和端口号（需要转换为网络字节序的格式）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">sockaddr_in sin;sin.sin_family = AF_INET;sin.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">8888</span>);<span class="hljs-comment">// 设置端口号，转换为网络字节序的格式sin.sin_addr.S_un.S_addr = INADDR_ANY; //监听任意的地址</span><br></code></pre></td></tr></table></figure><p>③将套接字描述符绑定到服务器地址（使用bind()方法）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(slisten, (LPSOCKADDR)&amp;sin, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(sin)) == SOCKET_ERROR)&#123;cout &lt;&lt; <span class="hljs-string">&quot;bind error !&quot;</span> &lt;&lt; endl;&#125;<br></code></pre></td></tr></table></figure><p>④将套接字描述符设置为监听套接字描述符（使用listen()方法），等待来自客户端的连接请求，监听套接字维护未完成连接队列和已完成连接队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(slisten, <span class="hljs-number">5</span>) == SOCKET_ERROR)&#123;cout &lt;&lt; <span class="hljs-string">&quot;listen error !&quot;</span> &lt;&lt; endl;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><p>⑤从已完成连接队列中取得队首项，返回新的已连接套接字描述符（使用accept()方法），如果已完成连接队列为空，则会阻塞</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//循环接受数据SOCKET sClient;  //创建连接的套接字sockaddr_in remoteAddr;int nAddrlen = sizeof(remoteAddr); //用于接受客户端地址char revData[255]; //存储接受的数据while(1)&#123;    cout &lt;&lt; &quot;等待连接...\n&quot;;sClient = accept(slisten, (SOCKADDR *)&amp;remoteAddr, &amp;nAddrlen); //和客户端所使用的connect()方法对应&#125;</span><br></code></pre></td></tr></table></figure><p>⑥从已连接套接字描述符读取来自客户端的请求（使用recv()方法）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">recv</span>(sClient, revData, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span>)&#123;revData[ret] = <span class="hljs-number">0x00</span>;<span class="hljs-built_in">printf</span>(revData);&#125;<br></code></pre></td></tr></table></figure><p>⑦向已连接套接字描述符写入应答（使用send()方法）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *sendData = <span class="hljs-string">&quot;你好，TCP客户端！ \n&quot;</span>;<span class="hljs-built_in">send</span>(sClient, sendData, <span class="hljs-built_in">strlen</span>(sendData), <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>⑧关闭已连接套接字描述符（使用close()方法）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">closesocket</span>(sClient);<br></code></pre></td></tr></table></figure><p>⑨最后关闭监听的套接字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">closesocket</span>(slisten);<br></code></pre></td></tr></table></figure></li><li><p>关于服务器和客户端编程的异同：</p><p>相同点：首先都要通过**socket()<strong>创建套接字描述符，并设置服务器的IP地址和端口号，端口号都要通过</strong>htons()**转换为网络字节序的格式，最后都要及时关闭所有开启的套接字描述符。</p><p>差异点：客户端是先发起请求，再接收来自服务器的应答，所以是先使用**send()<strong>，再使用</strong>recv()<strong>；而服务器则是先接受来自客户端的请求，在做出应答，所以是先使用</strong>recv()<strong>，再使用</strong>send()**。</p></li></ul></li></ul></li><li><p>关于在UDP与TCP编程中经常使用的几种函数：</p><ul><li><p><strong>socket()函数</strong></p></li><li><p><strong>send()函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">send</span><span class="hljs-params">(SOCKET s, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> FAR *buf, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> flags)</span></span><br></code></pre></td></tr></table></figure><p>无论是客户还是服务器应用程序，都是使用send()函数来向TCP连接的另一端发送数据。注意几个关键词：TCP连接，发送。</p><p>①第一个参数指定了套接字描述符</p><p>②第二个参数指明一个存放应用程序要发送数据的缓冲区</p><p>③第三个参数指明实际要发送的数据的字节数</p><p>④第四个参数一般置为0</p></li><li><p><strong>recv函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recv</span><span class="hljs-params">(SOCKET s, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> FAR *buf, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> flags)</span></span><br></code></pre></td></tr></table></figure><p>无论是客户还是服务器应用程序，都是使用recv()函数来向TCP连接的另一端接收数据。注意几个关键词：TCP连接，接收。</p><p>①第一个参数指定接收端套接字描述符；</p><p>②第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；</p><p>③第三个参数指明buf的长度；</p><p>④第四个参数一般置0。</p></li></ul></li></ul><h1 id="第三章-运输层"><a href="#第三章-运输层" class="headerlink" title="第三章 运输层"></a>第三章 运输层</h1><ul><li><p>运输层协议为运行在不同主机上的应用进程之间提供了<strong>逻辑通信</strong>功能</p></li><li><p>将主机间交付扩展到进程间交付被称为运输层的<strong>多路复用</strong>和<strong>多路分解</strong></p><ul><li>将运输层报文段中的数据交付到正确的套接字的工作被称为<strong>多路分解</strong></li><li>在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，所有这些工作被称为<strong>多路复用</strong></li></ul></li><li><p>多路复用的要求：①套接字有唯一标识符②每个报文段有特殊字段来指示该报文段所要交付到的套接字。这些特殊字段是<strong>源端口号字段</strong>和<strong>目的端口号字段</strong>。</p></li><li><p>运输层是怎样实现分解服务的？</p><p>在主机上的每个套接字能够分配一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字，然后报文段中的数据通过套接字进入其所连接的进程。</p></li><li><p>无连接的多路复用和多路分解：</p><p>在UDP编程中，通过使用socket()函数能够创建起一个套接字描述符。但当通过这种方法创建UDP套接字时，运输层是自动为这个套接字分配一个端口，范围是1024~65535。也可以通过bind()方法，为这个UDP套接字指定一个端口。</p><p>一个UDP套接字是由一个二元组全面标识的：它包含一个目的IP地址和一个目的端口号</p><p>对于UDP而言，如果两个UDP报文段有不同的源IP地址和/或源端口号，但是具有相同的目的IP地址和目的端口号，那么它们俩将通过相同的目的套接字被定向到相同的目的进程。</p></li><li><p>面向连接的多路复用和多路分解;</p><p>一个TCP套接字是由一个四元组全面标识的：它包含源IP地址、源端口号、目的IP地址、目的端口号</p><p>与UDP不同的是，两个具有不同源IP地址或源端口号的TCP报文段将被定向到两个不同的套接字，除非它们俩携带了初始创建连接的请求。</p></li><li><p>具体研究研究<strong>无连接运输：UDP</strong></p><p>对于任何一种协议，都要考虑到运输层最低限度必须提供一种复用/分解服务，以便在网络层与正确的应用级进程之间传递数据。</p><p>UDP就只是做了运输协议能够做的最少工作。除了复用/分解功能及少量的差错检测外，它几乎没有对IP增加别的东西。也就是说，如果开发人员选择了UDP，那么这个应用程序差不多就是直接与IP打交道。</p><p>那么什么时候选用UDP？</p><ul><li><p><strong>关于发送什么数据以及何时发送的应用层控制更为精细</strong></p><p>由于TCP有一个拥塞控制机制，这就导致当源和目的主机间的一条或多条链路变得极度拥塞时，运输层TCP发送方就会被遏制。但之后TCP仍将继续重新发送数据报文段直到目的主机收到此报文段并加以确认。它是不管可靠交付需要多长时间的。</p><p><strong>但</strong>实时应用通常要求最小的发送速率，不希望过分的延迟报文段的发送，并且能够容忍一些数据的丢失，基于这些的应用程序就可以使用UDP</p></li><li><p><strong>无须连接建立</strong></p><p>UDP并不需要像TCP那样在开始传输数据之前要进行三次握手，它无需任何准备就能够进行数据传输。所以UDP就没有建立连接的时延。</p></li><li><p><strong>无连接状态</strong></p><p>这个连接状态包括接收和发送缓存、拥塞控制参数、序号与确认号的参数。TCP是需要在端系统中维护连接状态的以实现它的拥塞控制机制。而UDP不维护连接状态，也不跟踪这些参数。所以对那些专门用于某种特定应用的服务器当应用程序运行在UDP上时，能够支持更多的活跃用户。</p></li><li><p><strong>分组首部开销小</strong></p><p>对于TCP报文段20字节的首部开销，UDP仅有8字节。</p></li></ul></li><li><p>UDP报文段结构：</p><p>应用层数据占用UDP报文段的数据字段，数据字段要么包含一个查询报文，要么包含一个响应报文。</p><p>UDP首部只有4个字段，每个字段由两个字节组成。4个字段分别为：源端口号、目的端口号、长度、检验和</p><p>通过两个端口号能够使目的主机将应用数据交给运行在目的端系统中的相应进程。（这里就是执行分解功能）</p><p>长度字段指示了在UDP报文段中的字节数。</p><p>接收方使用检验和来检查该报文段中是否出现了差错。</p></li><li><p>UDP检验和：提供了差错检测功能，也就是：检验和用于确定当UDP报文段从源到达目的地移动时，其中的比特是否发生了变化。</p><p>但要注意的是，UDP只提供了差错检测，它并不提供差错恢复的能力。</p></li><li><p>可靠数据传输（rdt）原理：</p><ul><li><p><strong>rdt1.0</strong>：经完全可靠信道的可靠数据传输</p><p>这是最简单的一种情况，底层信道是完全可靠的。</p><p>rdt的发送端只通过rdt_send(data)事件接受来自较高层的数据，产生一个包含该数据的分组（经由make_pkt(data)动作），并将数据上传给较高层（通过deliver_data(data)动作）。而rdt_rcv(packet)事件是由较低层协议的过程调用生产的。</p><p>在这个简单的协议中，一个单元数据与一个分组是没有差别的。而且所有分组是发送方流向接收方；有了完全可靠的信道，接收方就不需要提供任何反馈信息给发送方。</p></li><li><p><strong>rdt2.0</strong>：经具有比特差错信道的可靠数据传输</p><p>在计算机网络环境中，基于<strong>肯定确认</strong>和<strong>否定确认</strong>这样的重传机制的可靠数据传输协议被称为<strong>自动重传请求（ARQ）</strong>协议</p><p>为处理比特差错，ARQ协议还需要另外三种协议功能：</p><p>①<strong>差错检测</strong>：带有差错检测的比特将会被汇集到rdt2.0数据分组的分组检验和字段中。</p><p>②<strong>接收方反馈</strong>：rdt2.0协议将从接收方向发送方回送ACK与NAK分组。理论上这些分组只需要一个比特——用0表示NAK，用1表示ACK。</p><p>③<strong>重传</strong>：接收方收到有差错的分组时，发送方将重传该分组文。</p><p>具体的发送过程就为：初始状态发送端协议等待来自上层传下来的数据。当rdt_send(data)事件出现是，发送方将产生一个带有检验和的、包含待发送数据的分组（sndpkt = make_pkt(data, checksum)），然后经由udt_send(sndpkt)操作发送该分组。发送端执行完上述的操作后，发送端就开始等待来自接收端的ACK分组或NAK分组。如果收到一个ACK分组（rdt_rcv(rcvpkt) &amp;&amp; isACK(rcvpkt)），就意味着协议将会返回到等待来自上层的数据的状态。如果收一个NAK分组，就重传上一个分组（udt_send(sndpkt)）。</p><p>在这个过程中，当发送方处于等到接收ACK或NAK分组时，它是不会再接收来自上层的数据，也就是udt_send(next_sndpkt)事件不会出现。</p><p>rdt2.0有一个致命的缺陷：ACK或NAK分组可能受损。如果一个ACK或NAK分组受损，发送方无法知道接收方是否正确接受了上一块发送的数据。</p><p>《自顶而下》中考虑了处理受损ACK和NAK时的3种可能性：</p><ul><li>在协议中引入一种新型发送方到接收方的分组，接收方则将复述其回答。</li><li>增加足够的检验和比特，以使发送方检测差错和恢复差错。</li><li>当发送方收到含糊不清的ACK或NAK分组时，只需要重传当前数据分组。这种方法是在发送方到接收方的信道中引入<strong>冗余分组</strong>。冗余分组的根本困难在于接收方不知道它上次所发送的ACK或NAK是否被发送方正确地收到。因为它不知道接收到的分组是新的还是一次重传的。</li></ul><p>解决这些问题的方法是在数据分组中添加一个新字段，让发送方对其数据分组编号，即将发送数据分组的<strong>序号</strong>放在该字段。于是就有了rdt2.0的一系列修订版</p><p><strong>rdt2.1</strong>：</p><p>发送方和接收方的FSM的状态数都是之前版本的两倍。因为在修订后的协议中，要求协议状态此时必须反映出目前正发送的分组或希望接收的分组的序号是0还是1。它使用了从接收方到发送方的肯定确认和否定确认。</p><p><strong>rdt2.2</strong>：</p><p>是在比特差错信道上实现的一个无NAK的可靠数据传输协议。与2.1相比，接收方此时必须包括由一个ACK报文所确认的分组序号（可以通过在接收方FSM中，在make_pkt()中包括参数ACK 0或ACK 1来实现），发送方此时必须检查接收到的ACK报文中被确认的分组序号（可以通过在发送方FSM中，在isACK()中包括参数0或1来实现）</p></li><li><p><strong>rdt3.0</strong>：经具有比特差错的丢包信道的可靠数据传输（也被特定称为<strong>比特交替协议</strong>）</p><p>3.0主要是解决怎样检测丢包和发生丢包后应该做什么。</p><p>丢包的标准是什么？在实践中采取的方法是发送方明智地选择一个时间值，以判断可能发生了丢包。</p><p>如果在这个时间内没有收到ACK，则重传该分组。为了实现基于时间的重传机制，需要一个<strong>倒计数定时器</strong>，在一个给定的时间量过期后，可中断发送方。所以，发送方需要做的是：①每次发送一个分组（包括第一次分组和重传分组）时，便启动一个定时器；②响应定时器中断；③终止定时器</p></li></ul></li><li><p>rdt3.0依然有它不足之处：它是一个停等协议。这也就意味着rdt3.0有着非常低的发送方利用率。为解决这个问题，就有了新的可靠数据传输协议：流水线可靠数据传输协议。</p><p>①增加序号的范围，因为每个输送中的分组必须有一个唯一的序号，而且也许有多个在输送中的未确认报文，而且也许有多个在输送中的未确认报文。</p><p>②协议的发送方和接收方两端需要缓存多个分组。发送方最低限度应当能缓冲那些已发送但没有确认的分组。</p><p>③所需的序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏以及延时过大的分组。</p><p>解决流水线的差错恢复的两种基本方法是：①<strong>回退N步（GBN）</strong>②<strong>选择重传（SR）</strong></p><ul><li><p><strong>回退N步（GBN）</strong>——或被称为<strong>滑动窗口协议</strong></p><p>在<strong>回退N步（GBN）协议</strong>中，允许发送方发送多个分组而不需要等待确认，但也受限于在流水线中未确认的分组数不能超过某个最大允许数N。</p><p>在GBN协议中，发送方看到的序号被分为四个部分：<strong>已被确认的序号</strong>、<strong>发送但还未确认的序号</strong>、<strong>可用但还未发送的序号</strong>、<strong>不可用的序号</strong>。</p><p>将<strong>发送但还未确认的序号</strong>的第一个序号定义为<strong>基序号（base）</strong>，将<strong>可用但还未发送的序号</strong>的第一个序号定义为**下一个序号(nextseqnum)**，这两个部分的序号长度我们设为N，也就是窗口的长度。但这个N的大小是会被限制的。</p><p>GBN发送方必须响应三种类型的事件：</p><ul><li><strong>上层的调用</strong>：当上层调用rdt_send()时，发送方首先检查发送窗口是否已满，，即是否有N个已发送但未被确认的分组。如果窗口未满，则产生一个分组并发送，同时更新相应的变量；如果窗口已满，发送方只需将数据返回给上层，隐式地指示上层该窗口已满。这里似乎是通过一个判断语句来实现，但在实际实现中，发送方更可能缓存这些数据，而不是立刻发送，或者使用同步机制允许上层在仅当窗口不满时才调用rdt_send()。</li><li><strong>收到一个ACK</strong>：在GBN协议中，对序号为n地分组采用的确认方式是<strong>累计确认</strong>的方式，来表明接收方已正确的接收到序号为n的之前的所有分组（包括n）</li><li><strong>超时事件</strong>：“回退N步”就来源于出现丢失和时延过长分组时发送方的行为。如果出现超时，发送方将重传所有已发送但还未被确认的分组。如果收到一个ACK，但仍有已发送但未被确认的过的分组，则定时器被重新启动；如果没有已发送但未被确认的过的分组，则停止该计时器。</li></ul></li><li><p><strong>选择重传（SR）</strong></p><p>通过让发送方仅重传那些它怀疑在接收方出错的分组（即丢失或受损）而避免了不必要的重传。这种个别的、按需的重传要求接收方逐个确认正确接收的分组。再次用窗口长度N来限制流水线中未完成的、未被确认的分组数。但与GBN不同的是，发送方已经收到了对窗口中某些分组的ACK</p></li></ul></li><li><p>面向连接的TCP：之所以是面向连接的，是因为在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先相互“握手”，即它们必须相互发送某些预备报文段，以建立确保数据传输的参数。</p><p>这是一种逻辑连接，其共同状态仅保留在两个通信端系统的TCP程序中。并且提供的是<strong>全双工服务</strong>——如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据就能够从进程B流向进程A的同时，也从进程A流向进程B。TCP连接也总是<strong>点对点</strong>，即在单个发送方与单个接收方之间的连接。</p><p>在TCP编程中，曾提到过发起连接的这个进程被称为<strong>客户进程</strong>，另一个进程被称为<strong>服务器进程</strong>。客户应用进程首先要通知客户运输层它要与服务器上的一个进程来建立一条连接，这个过程通过connect()函数来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connect</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,struct sockaddr_in * serv_addr,<span class="hljs-keyword">int</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p>sockaddr_in的对象serv_addr携带有服务器进程的端口、IP地址等信息。</p></li><li><p>TCP报文段结构：首部包括——<strong>源端口号和目的端口号</strong>、32比特的<strong>序号字段</strong>，32比特的<strong>确认号字段</strong>，16比特的<strong>接收窗口字段</strong>，4比特的<strong>首部长度字段</strong>，可选与变长的<strong>选项字段</strong>，6比特的<strong>标志字段</strong></p><ul><li><p><strong>序号与确认号</strong>：这是TCO报文段首部中最重要的两个字段，它们保证了TCP的可靠传输服务。</p><p>在TCP中，它将数据看作一个无结构、有序的字节流。要注意的是，<strong>一个报文段的序号</strong>是该报文段首字节的字节流编号。而<strong>确认号</strong>是指一个主机期望从另一个主机收到的下一个字节的序号。举个例子：</p><p>主机A向主机B发送一个字符C，当用键入“C”并按下回车键后，发送的报文段简单来说就是“Seq=42，ACK=79，data=’C’”；主机B收到“C”后，回显”C”，报文段就是“Seq=79，ACK=43，data=’C’”；主机A再确认收到回显的”C”，报文段就是“Seq=43，ACK=80”</p></li></ul></li><li><p>同rdt协议一样，TCP也采用超时/重传机制来处理报文段的丢失问题。但要注意的问题就是超时间隔长度的设置。虽然，超时间隔必须大于该连接的往返时间（RTT）</p><ul><li><p>往返时间的估计</p><p>报文段的样本RTT（即SampleRTT）就是从某报文段被发出到对该报文段的确认被收到之间的时间量。大多数的TCP实现仅在某个时刻做一次SampleRTT测量，而不是为每个发送的报文段测量一个SampleRTT。这也就是说，在任意时刻，仅为一个已发生的但目前尚未被确认的报文段估计SampleRTT，从而产生一个接近每个RTT的新SampleRTT值。同时，TCP也决不会为已被重传的报文段计算SampleRTT；它仅为传输一次的报文段测量SampleRTT。</p><p>由于设备等的原因，SampleRTT是一个波动的值，所以为了估计一个典型的RTT，需要设计一个公式来对SampleRTT求取平均值EstimateRTT：<br>$$<br>EstimateRTT = (1-\alpha)EstimateRTT+\alpha SampleRTT<br>$$<br>$\alpha$的值一般取为0.125，也就是EstimateRTT是SampleRTT的一个加权平均值，但这个加权平均值对最近的样本赋予的权值要大于对旧样本赋予的权值。</p><p>此外还定义了RTT的偏差值DevRTT，用于估算SampleRTT一般会偏离EstimateRTT的程度：<br>$$<br>DevRTT = (1-\beta)DevRTT+\beta |SampleRTT-EstimateRTT|<br>$$<br>$\beta$的值一般取为0.25，DevRTT是一个SampleRTT与EstimateRTT之间差值的EWMA（<strong>指数加权移动平均</strong>）</p></li><li><p>设置和管理重传超时间隔</p><p>TCP的超时间隔就应该根据EstimateRTT和DevRTT的值来进行设计。</p><p>设这个新的变量为TimeoutInterval，与上述两个变量的关系式就为：<br>$$<br>TimeoutInterval = EstimateRTT + 4DevRTT<br>$$<br>设计原理为：TimeoutInterval的值必须大于EstimateRTT，以避免造成不必要的重传；但也不能大太多，否则当报文段丢失时，TCP不能很快地重传该报文段，导致数据传输时延大。所以就在EstimateRTT的基础上增加了一个余量：当SampleRTT波动较大时，就增大这个余量；当波动较小时，就减小这个余量，于是就使用了DevRTT</p><p>在标准文档中，推荐的初始TimeoutInterval值为1秒。同时当出现超时后，TimeoutInterval值将加倍，以免即将被确认的猴急报文段过早出现超时。一旦收到报文段并更新EstimateRTT，就使用上述的公式对TimeoutInterval进行再次计算。</p></li></ul></li><li><p>TCP发送方有三个与发送和重传有关的主要事件：从上层应用程序接收数据、定时器超时、接收ACK</p><p>①第一个主要事件发生：TCP从应用程序接收数据。将数据封装在一个报文段中，并把该报文段交给IP。</p><p>②如果定时器还没有为某些其他的报文段而运行，则当报文段被传给IP时，TCP就启动该定时器。</p><p>③第三个主要事件发生：TCP将ACK的值y与它的变量SendBase进行比较。TCP状态变量SendBase是最早未被确认的字节的序号，也就是说SendBase-1是指接收方已正确按序接收到的数据的最后一个字节的序号。TCP采取累计确认，所以y确认了字节编号在y之前的所有字节都已经收到。如果$y &gt; SendBase$，则该ACK是在确认一个或多个先前未被确认的报文段。所以发送方就更新SendBase变量；如果当前有未被确认的报文段，TCP还需要重启定时器。</p></li><li><p>TCP的差错恢复机制是GBN协议还是SR协议？都不是任意的单一，而是GBN协议与SR协议的混合体</p><p>①TCP发送方仅需维持已发送到过的但未被确认的字节的最小序号（SendBase）和下一个要发送的字节的序号（NextSeqnum）。但与GBN不同的是，假设发送方将发送一组长度为N的报文段时，并且对任意一个分组n&lt;N，TCP并不会像GBN那样重传分组n的同时还要去重传其所有后继分组，TCP至多重传一个报文段，即报文段n。</p><p>②TCP的<strong>选择确认</strong>机制允许TCP接收方有选择地确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段。</p></li><li><p>TCP的<strong>流量控制服务</strong>：用于消除发送方使接收方缓存溢出的可能性。流量控制的本质是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配。但<strong>拥塞控制</strong>的存在，使得TCP发送方也可能因为IP网络的拥塞而被遏制发送。流量控制和拥塞控制所采取的动作非常相似，但两者所针对的原因完全不同。</p></li><li><p>TCP是如何提供流量控制服务的？</p><p>先做一个<strong>全局的假设：TCP接收方丢弃失序的报文段</strong></p><p>TCP通过让<strong>发送方</strong>维护一个称为<strong>接收窗口</strong>的变量来提供流量控制。接收窗口用于给发送方一个指示——该接收方还有多少可用的缓存空间。因为TCP是全双工通信，所以说就相当于一条连接的两端都要各自维护一个接收窗口。</p><p>设某个主机为来自另一个主机的连接分配了一个接收缓存，用RcvBuffer来表示其大小；用LastByteRead来表示从缓存中读出的数据流的最后一个字节的编号；用LastByteRcvd表示从网络上到达并放入这个缓存中的数据流的最后一个字节的编号。</p><p>由于TCP不允许已分配的缓存溢出，所以就有了一个必要条件：<br>$$<br>LastByteRcvd-LastByteRead≤RcvBuffer<br>$$<br>用rwnd来表示接收窗口，根据缓存可用空间的数量来设置：<br>$$<br>rwnd=RcvBuffer-[LastByteRcvd-LastByteRead]<br>$$<br>TCP连接就是通过变量rwnd来提供流量控制服务的：主机通过把当前的rwnd值放入它发给另一个主机的报文段接收窗口字段中，通知这个主机在该连接的缓存中还有多少可用空间。另一个主机在整个连接的生命周期中，都要保证：<br>$$<br>LastByteRead-LastByteAcked≤rwnd<br>$$</p></li><li></li><li><p>TCP连接管理——如何建立和拆除一条TCP连接</p><ul><li><p><strong>TCP连接建立的过程——3次握手</strong></p><p>①第一步：客户端的TCP首先向服务器端的TCP发送一条特殊的报文段——它不包含应用层数据，但它的首部中的一个标志位（<strong>SYN比特</strong>）被置为1。这个特殊的报文段被称为<strong>SYN报文段</strong>。</p><p>②第二步：包含TCP SYN报文段的IP数据包到达服务器主机后，服务器会从该数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文。这个允许连接的报文段依然不包含应用层数据，但是它的首部包含了3个重要的信息：SYN比特被置为1，确认号被置为client_isn+1，服务器选择自己的初始序号server_isn。这个报文段被称为<strong>SYNACK报文段</strong></p><p>③第三步：在收到SYNACK报文段后，客户也要给该连接分配缓存和变量。客户主机则向服务器发送另一个报文段，这最后一个报文段对服务器的允许连接的报文段进行了确认。因为连接建立成功，所以SYN就需要被置为0。该三次握手的第三个阶段可以在报文段负载中携带客户到服务器的数据。</p></li><li><p><strong>TCP连接建立后</strong></p><p>完成上述三个步骤后就正式建立起了一条TCP连接，客户和服务器主机也就能够互相发送包含应用层数据的报文段了。在之后的每一个报文段，SYN都被置为0</p></li><li><p><strong>TCP连接的拆除</strong></p><p>一条TCP连接的的两个进程中的任意一个都能够终止这条连接。当连接结束后，主机中的“资源”（即缓存和变量）将被释放。当客户进程发起一个关闭连接的命令时，客户TCP会向服务器进程发送一个<strong>首部标志位FIN比特被置为1</strong>的特殊TCP报文段；当服务器接收到这个报文段后就向发送方会送一个确认报文段并发送它自己的、FUN比特被置为1的终止报文段；最后客户对这个来自服务器的终止报文段进行确认。至此，在两台主机上用于该TCP连接的所有资源就全部被释放。</p></li></ul></li><li><p><strong>拥塞控制</strong></p><ul><li><p>拥塞的原因及代价：</p><ul><li><strong>原因</strong>：简单得来说就是数据发送方投放到网络中的数据量超过了网络的承载能力。网络的承载能力取决于网络上可用的带宽最小路径，这也就是瓶颈所在。每种网络设备接口往往都有缓冲区，超量的数据无法从瓶颈路径发送，就只能在缓存区排队，当积压的数据量超过了缓存区大小，就会发生丢弃。</li><li><strong>代价</strong>：①当分组的到达速率接近链路容量时，分组将经历巨大的排队时延。②发送方必须执行重传以补偿因为缓存溢出而丢弃（丢失）的分组。③发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本。④当一个分组沿一条路径被丢失时，每个上游路由器由于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了。</li></ul></li><li><p>拥塞控制的方法：根据网络层是否为运输层拥塞控制提供显式帮助来区分拥塞控制的类别</p><ul><li><p><strong>端到端拥塞控制</strong>：在端到端拥塞控制中，网络层并没有为运输层拥塞控制提供显示帮支持。也即网络中即使存在拥塞，端系统也必须通过对网络行为的观察来进行推断。TCP是采用端到端的方法解决拥塞控制，因为IP层不会向端系统提供有关网络拥塞的反馈信息。</p><p>在TCP中，<strong>TCP报文段的丢失</strong>会被认为是一个网络拥塞的迹象，然后TCP就会相应地减小其窗口长度。在最新的TCP拥塞控制中，还<strong>通过使用增加的往返时延值</strong>作为网络拥塞程度增加的指示。</p></li><li><p><strong>网络辅助的拥塞控制</strong>：在网络辅助的拥塞控制中，路由器向发送方提供关于网络中拥塞状态的显示反馈信息。这种反馈仅仅只需要一个比特就能够指示链路中的拥塞情况。而对于网络辅助的拥塞控制，拥塞信息从网络反馈到发送方通常有两种方式：经由接收方的网络反馈和直接网络反馈</p><ul><li>直接反馈信息：是由网络路由器直接发给发送方。通常采用<strong>阻塞分组</strong>的形式</li><li>接收方的反馈信息：路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生。一旦收到了一个标记的分组，接收方就会向发送方通知该网络拥塞指示。这种信息的反馈需要经过一个完整的往返时间。</li></ul></li></ul><p>默认情况下，因特网版本的IP和TCP是采用的是端到端的拥塞控制方法。</p></li></ul></li><li><p><strong>TCP拥塞控制</strong>：它的端到端的拥塞控制机制的具体方法是<strong>让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率</strong>。但这种会引发三个问题：</p><ul><li><p>TCP发送方是如何限制向其他连接发送流量的？</p><p>TCP连接的每一端都是由一个接收缓存、一个发送缓存、几个变量组成的。此外，运行在发送方的TCP拥塞控制机制跟踪一个额外的变量——拥塞窗口，cwnd。它对一个TCP发送方能向网络中发送流量的速率进行限制。</p></li><li><p>TCP发送方是如何感知它与目的地之间的路径上出现了拥塞的？</p><p>将一个TCP发送方的”丢包事件“定义为：要么出现超时，要么收到来自接收方的3个冗余ACK。一旦出现了这两种情况中的任一，发送方就认为在发送方到接收方的路径上出现了拥塞的指示。</p></li><li><p>TCP发送方怎样确定它应当发送的速率？（这也是最关键的问题）</p><p>TCP所确定的速率即要使得网络不会拥塞，也同时能够充分利用所有可用的带宽。TCP通过下述指导性原则来解决这个问题：</p><ul><li><p><strong>一个丢失的报文段意味着拥塞，因此当丢失报文段时应当降低TCP发送方的速率</strong></p><p>从拥塞控制的观点来看，可以理解为TCP发送方应当如何减小它的拥塞窗口长度，即减小其发送速率，以应对这种推测的丢包事件。</p></li><li><p><strong>一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率</strong></p></li><li><p><strong>带宽探测</strong></p><p>给定ACK指示源到目的地路径无拥塞，而丢包事件指示路径拥塞，TCP调节其传输速率的策略是<strong>增加其速率以响应到达的ACK，除非出现丢包事件，此时才减小传输速率</strong>。所以为了探测拥塞开始出现的速率，TCP发送方增加它的传输速率，并从该速率后退，进而再次探测以查明拥塞开始的速率是否变化。</p></li></ul></li></ul></li><li><p>TCP拥塞控制算法：包括3个主要的部分——①慢启动②拥塞避免③快速恢复</p><ul><li><p><strong>慢启动</strong>：</p><p>当一条TCP连接开始时，cwnd的值通常是初始化为一个MSS的较小值，这样初始的发送速率就是$\frac{MSS}{RTT}$。并且每当发送方收到一个来自接收方的对传输的报文段的确认后，就增加1个MSS。收到n个就增加n个MSS。因此，TCP发送速率起始慢，但在慢启动阶段是以指数增长的。</p><p>何时结束这种指数增长？</p><p>①如果存在一个由超时指示的丢包事件，TCP发送方将cwnd设置为1并重启慢启动过程。同时还将慢启动阈值ssthresh设置为$\frac{cwnd}{2}$</p><p>②当cwnd=ssthresh时，结束慢启动并且TCP转移到拥塞避免模式</p><p>③当检测到3个冗余ACK，TCP执行快速重传并进入快速恢复状态</p></li><li><p><strong>拥塞避免</strong>：</p><p>一旦进入拥塞避免状态，cwnd的值大约是上次遇到拥塞时的值的一半，这也就表明距离拥塞并不远了。所以TCP无法每过一个RTT再将cwnd的值翻倍，而是每个RTT只将cwnd的值增加一个MSS。最常用的方法是对于TCP发送方无论何时到达一个新的确认，就将cwnd增加一个MSS字节（MSS/cwnd）。</p><p>但应该何时结束拥塞避免的线性增长？</p><p>当出现超时时，与慢启动的情况一样，cwnd的值被设置为1个MSS。当丢包事件发生时，ssthresh的值被更新为cwnd值的一半。即使是由于一个三个冗余ACK事件触发丢包事件，TCP是将cwnd的值减半，并且当收到3个冗余的ACK，将ssthresh的值记录为cwnd的值的一半。</p></li><li><p><strong>快速恢复</strong>：</p><p>在快速恢复中，对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余的ACK，cwnd的值增加一个MSS。最终，当对丢失报文段的一个ACK到达时，TCP在降低cwnd后进入拥塞避免状态。若出现超时，快速恢复执行与慢启动和拥塞避免类似的动作后，迁移到慢启动状态；当丢包事件出现时，cwnd的值被设置为1个MSS，并且ssthresh的值设置为cwnd的一半。</p></li></ul></li><li><p>根据《自顶而下》P179的TCP拥塞控制的FSM描述，进行TCP拥塞控制的简易编程模拟实验</p><p>（是在Window10下面做的，还未进行linux的编程）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 设置一些判断位</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AllNormal 0<span class="hljs-comment">// 传输正常</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Time_out 1<span class="hljs-comment">// 传输超时</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DupAck 2<span class="hljs-comment">// 3个冗余ACK</span></span><br><br><span class="hljs-comment">// 设置一些必要的全局参数</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MSS = <span class="hljs-number">500</span>;<span class="hljs-comment">// 是以慢启动中的例子将单个报文段长度设置为的500字节(B)</span><br><span class="hljs-keyword">int</span> ssthresh = <span class="hljs-number">1460</span>;<span class="hljs-comment">// 在linux内核中是将sstresh设置为的1460</span><br><span class="hljs-keyword">int</span> cwnd = <span class="hljs-number">3</span>*MSS;<span class="hljs-comment">// 在linux内核中同样是将cwnd初始为的3，以MSS作为的单位</span><br><span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<span class="hljs-comment">// 传播的轮次</span><br><span class="hljs-keyword">int</span> DataTrans = <span class="hljs-number">0</span>;<span class="hljs-comment">// 每次传输成功传输的字节</span><br><span class="hljs-keyword">int</span> DataSum;<span class="hljs-comment">// 本次传输的总数据量大小，单位是字节(B)</span><br><br><span class="hljs-comment">/* 设置一个函数来随机产生拥塞</span><br><span class="hljs-comment">返回值：</span><br><span class="hljs-comment">0：未丢包网络正常</span><br><span class="hljs-comment">1：重传计时器超时对应策略：慢启动</span><br><span class="hljs-comment">2：3个冗余ACK对应策略：快速恢复</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IsCongestion_Control</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cwnd)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> p = cwsn / MSS * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">rand</span>()%<span class="hljs-number">100</span> &lt; p)&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">rand</span>()%<span class="hljs-number">100</span> &lt; <span class="hljs-number">50</span>)&#123;<br>            <span class="hljs-keyword">return</span> Time_out;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> DupAck;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> AllNormal;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 数据的传输</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TransData</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">bool</span> isSlowStart = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 是否慢启动</span><br>    <br>    <span class="hljs-comment">// 传输数据</span><br>    DataTrans += cwnd;<br>    <span class="hljs-keyword">if</span> (cwnd &lt; ssthresh)&#123;<span class="hljs-comment">// 慢启动</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;第&quot;</span> &lt;&lt; index++ &lt;&lt; <span class="hljs-string">&quot;轮传输&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;慢启动：拥塞窗口cwnd=&quot;</span> &lt;&lt; cwnd/MSS &lt;&lt; <span class="hljs-string">&quot;,慢启动门限ssthresh=&quot;</span> &lt;&lt; ssthresh/MSS &lt;&lt; endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 也就是cwnd &gt;= ssthresh,造成拥塞避免</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;第&quot;</span> &lt;&lt; index++ &lt;&lt; <span class="hljs-string">&quot;轮传输&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;慢启动：拥塞窗口cwnd=&quot;</span> &lt;&lt; cwnd/MSS &lt;&lt; <span class="hljs-string">&quot;,慢启动门限ssthresh=&quot;</span> &lt;&lt; ssthresh/MSS &lt;&lt; endl;<br>    isSlowStart = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 根据数据传输过程中的isSlowStart标志位对是否拥塞进行判断</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsCongestion_Control</span>(cwnd))&#123;<span class="hljs-comment">// 没有拥塞</span><br>        <span class="hljs-keyword">if</span> (isSlowStart)&#123;<span class="hljs-comment">// 慢启动</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;检测到网络正常,将窗口加倍!\n&quot;</span>;<br>            cwnd *= <span class="hljs-number">2</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;检测到网络正常,将窗口线性增加!\n&quot;</span>;<br>            cwnd += MSS*(<span class="hljs-number">1.0</span>*MSS/cwnd)*cwnd/MSS;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsCongestion_Control</span>(cwnd) == Time_out)&#123;<span class="hljs-comment">// 超时的情况</span><br>        DataTrans -= cwnd;<br>        <br>        <span class="hljs-comment">// 慢启动</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;重传计时器超时,回退慢启动!门限置当前窗口减半，窗口置1!\n&quot;</span>;<br>        ssthresh = cwnd/<span class="hljs-number">2</span>;<br>        cwnd = <span class="hljs-number">1</span> * MSS;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsCongestion_Control</span>(cwnd) == DupAck)&#123;<span class="hljs-comment">// 3个冗余ACK</span><br>        cout&lt;&lt;<span class="hljs-string">&quot;收到3个重复ACK，采取快恢复策略!门限置当前窗口减半,窗口置新门限!\n&quot;</span>;<br>ssthresh=cwnd/<span class="hljs-number">2</span>;<br>cwnd=ssthresh;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;拥塞异常！发挥异常值：&quot;</span> &lt;&lt; <span class="hljs-built_in">IsCongestion_Control</span>(cwnd) &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (DataTrans &lt; DataSum)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;已经传输&quot;</span> &lt;&lt; DataTrans &lt;&lt; <span class="hljs-string">&quot;B,剩余为传输的数据为：&quot;</span> &lt;&lt; DataSum - DataTrans &lt;&lt; <span class="hljs-string">&quot;B\n&quot;</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;传输完毕！\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    cout &lt;&lt; endl;<br>    <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1000</span>*(cwnd%<span class="hljs-number">3</span>)+<span class="hljs-number">1</span>);<span class="hljs-comment">// 随机停1~3秒</span><br>    <span class="hljs-built_in">TransData</span>();<span class="hljs-comment">// 递归循环，直至数据发送完毕</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h1><ul><li><p>网络层被分解为两个相互作用的部分：<strong>数据平面</strong>和<strong>控制平面</strong></p></li><li><p>网络层的作用简单来说就是将分组从一台发送主机移动到一台接收主机。通过<strong>转发</strong>和<strong>路由选择</strong>来实现：</p><ul><li>转发：当一个分组到达某路由器的一条输入链路时，该路由器必须将该分组移动到适当的输出链路中。同时，转发也是数据平台中实现的唯一功能。通常用硬件来实现。</li><li>路由选择：主要是使用<strong>路由选择算法</strong>，以实现——当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径。通常用软件来实现。</li></ul></li><li><p><strong>网络服务模型</strong>定义了分组在发送与接收端系统之间的端到端运输特性。</p></li><li><p>网络提供的服务包括：</p><ul><li>确保交付：确保了分组最终到达目的地</li><li>具有时延上界的确保交付：在确保分组的交付的基础上，还规定了在特定的主机到主机时延上界内交付</li><li>有序分组交付：确保分组以它们发送的顺序到达目的地</li><li>确保最小带宽：之要发送主机以低于特定比特率的速率传输比特，则所有分组最终会交付到目的主机。</li><li>安全性：网络层能够在源加密所有数据报并在目的地解密这些分组，从而对所有运输层报文段提供机密性。</li></ul></li><li><p>因特网的网络层提供了单一的服务：<strong>尽力而为服务</strong>。但使用这种服务，传送的分组既不能保证以它们发送的顺序被接受，，也不能保证它们最终的交付；既不能保证端到端时延，也不能保证有最小的带宽。</p></li><li><p>路由器的4个组件：输入端口、交换结构、输出端口、路由选择处理器</p><ul><li><strong>输入端口</strong>：它执行的功能有——①在路由器中执行终结入物理链路的物理层功能；②与位于入链路远端的数据链路层交互来执行数据链路层功能；③查找功能</li><li><strong>交换结构</strong>：将路由器的输入端口连接到它的输出端口。这是一个网络路由器中的网络。</li><li><strong>输出端口</strong>：存储着从交换结构接收的分组，并通过执行必要的链路层和物理层功能在输出链路上传输这些分组</li><li><strong>路由选择处理器</strong>：执行控制平面功能和网络管理功能。在传统路由器中，执行路由选择协议；在SDN路由器中路由选择处理器负责与远程控制器通信，目的是接收由远程控制器计算的转发表项，并在该路由器的输入端口安装这些表项。</li></ul></li><li><p>路由器转发表的表项匹配规则：<strong>最长前缀匹配规则</strong>——在该表中寻找最长的匹配项，并向与最长前缀匹配</p></li><li><p><strong>查找</strong>在输入端口处理中可认为是最重要的动作，但必须采取许多其他的动作，包括：①必须出现物理层和链路层处理；②必须检查分组的版本号、检验和以及寿命字段，并且重写后两个字段；③必须更新用于网络管理的计数器。</p></li><li><p><strong>交换</strong>有三种方式：</p><ul><li><p><strong>经内存交换</strong>：最简单、最早的路由器是传统的计算机，在输入端口和输出端口间的交换实在CPU（路由选择处理器）的直接控制下完成的。此时不能同时转发两个分组，即使它们有不同的目的端口，因为类似于传统操作系统中的I/O设备一样，经过共享系统总线一次仅能执行一个内存读/写。</p><p>许多现代路由器仍然通过内存来进行交换，但与传统路由器的区别在于：目的地址的查找和将分组存储（交换）进适当的内存存储位置是由输入线路卡来处理的。</p></li><li><p><strong>经总线交换</strong>：输入端口经一根共享总线将分组直接传送到输出端口，并不需要路由选择处理器的干预。</p></li><li><p><strong>经互联网络交换</strong>：上面两种交换方式都受到单一、共享式总线带宽限制。要想克服它，就要使用更为复杂的互联网络。<strong>纵横式交换机</strong>是一种给由2N条总线组成的互联网络，它连接N个输入端口与N个输出端口，每条垂直的总线在交叉点与每条水平的总线交叉，交叉点通过交换结构控制器能够在任何时候开启和闭合。</p><p>纵横式交换机是<strong>非阻塞的</strong>，也就是只要没有其他分组当前被转发到该输出端口，转发到输出端口的分组将不会被到达输出端口的分组阻塞。但是若来自两个不同输入端口的两个分组，其目的地为相同的输出端口，则一个分组必须在<strong>输入端</strong>等待，因为在某个时刻经给定总线进能够发送一个分组。</p></li></ul></li><li><p>排队的位置和程度将取决于流量负载、交换结构的相对速率和线路速率。</p><ul><li><p>输入排队：这种排队发生在<strong>交换结构无法快速地使所有分组无时延地通过它传送</strong>。可能情况有不同输入端口向同一个输出端口输出；同一个输出端口的多个分组发往不同的输出端口。</p></li><li><p>输出排队：这种排队发生在<strong>当有多个输入端口的分组的目的地是相同的输出端口时</strong>。最极端的情况就是排队的分组数量够多，以至于耗尽了输出端口的可用内存。一旦可用内存被耗尽，要么丢弃到达的分组（采用一种叫作<strong>弃尾</strong>的策略），要么删除一个或多个已排队的分组为新来的分组腾出空间。</p><p>通常的做法是：在缓存填满之前便丢弃一个分组。这样还能同时向发送方提供一个拥塞信号。</p></li></ul></li><li><p>分组调度：这个讨论的是排队的分组是如何经输出链路传输的。</p><ul><li><p><strong>先进先出（First-in-First-out）</strong>：如同采取同种策略的数据结构栈，按照分组到达输出链路队列的相同次序来选择分组在链路上的传输。</p></li><li><p><strong>优先权排队（prioity queuing）</strong>：在这个规则下，到达输出链路的分组被分类放入输出队列中的优先权类。在实践中，网络操作员可以配置一个队列，这样携带网络管理信息的分组获得超过用户流量的优先权。当选择一个一个分组传输时，优先权排队规则将从队列为非空的最高优先权类中传输一个分组。在同一优先权类内的分组之间的选择通常以FIFO方式完成。</p><p>也就是说，假设分组1、3是高优先权，分组2是低优先权，到达链路的顺序是1 2 3，当分组1传输完毕后，因为2的优先权比3低，所以即使2比3先到达链路，3也比2先进行传输。</p></li><li><p><strong>循环排队（round robin queuing discipline）</strong>：在此规则下，分组依然像使用优先权排队那样被分类。但是在类之间不存在严格的服务优先权，循环调度器在这些类之间轮流提供服务。它同时使用所谓的<strong>保持工作排队</strong>规则，不允许链路保持空闲。若没有寻找到给定类的分组，再转移到下一个类。</p></li><li><p><strong>加权公平排队（weighted fair queuing, WFQ）</strong>：与循环排队有相似之处，WFQ调度器也以循环的方式为各个类提供服务，同时带有保持工作排队规则。</p><p>不同之处在于，WFQ对于每个类，在任何时间间隔内可能收到不同数量的服务。具体来说就是对每个类都分配一个权值，每个类将确保接收到的服务部分等于它所拥有的权值占所有分组排队等待传输的类别的权值之和的比。</p></li></ul></li><li><p>网际协议：内容包括IPv4、IPv6以及IP编址</p><ul><li><p>IPv4数据报格式：</p><p>①<strong>版本（号）</strong>：占4比特，规定了数据报的IP协议版本。通过查看版本号，<strong>路由器</strong>能够确定如何解释IP数据报的剩余部分。</p><p>②<strong>首部长度</strong>：占4比特，用来确定IP数据报中载荷实际开始的地方。</p><p>③<strong>服务类型</strong>：为了使不同类型的IP数据报能相互区别开来。</p><p>④<strong>数据报长度</strong>：指示出IP数据报的总长度，以字节计。占16比特，所以说IP数据报的理论最大长度为65535字节。</p><p>⑤<strong>标识、标志、片偏移</strong>：这三个字段与IP分片有关，但是在最新的IPv6中，已经不允许在路由器上对分组分片。这三个部分一共占了32比特。</p><p>⑥<strong>寿命（TTL）</strong>：占8比特，用来确保数据报不会永远在网络中循环。每当有一台路由器处理该数据报时，TTL的值减1，当减为0时就丢弃该数据报。</p><p>⑦<strong>协议</strong>：占8比特。指示了IP数据报的数据部分应交给哪个特定的运输层协议。例如值为6，就交给TCP；值为17，就交给UDP。IP数据报中的协议号所起到的作用类似于运输层报文段中端口号字段所起的作用。协议号是<strong>将网络层与运输层绑定到一起的黏合剂</strong>，而端口号是<strong>将运输层和应用层绑定到一起的黏合剂</strong>。</p><p>⑧<strong>首部检验和</strong>：用于帮助路由器检测收到的IP数据报的比特错误。具体计算方法是：将首部中的每2个字节当作一个数，用<strong>反码</strong>算术对这些数求和。</p><p>⑨<strong>源和目的IP地址</strong>：在源IP字段中插入它的IP地址，在目的IP地址中插入最终的目的地地址。</p><p>⑩<strong>选址</strong>：选项字段允许IP首部被扩展。这一项在IPv4中不一定有，但在IPv6中一定没有。</p><p>⑪<strong>数据</strong>：这是最重要的字段，这是数据报存在的首要理由。</p></li><li><p>IPv4数据报分片</p><p>由于并不是所有链路层协议都能承载相同长度的网络层分组。有的协议能够承载大数据报，而有的写以只能承载小分组。一个链路层帧所能承受的最大数据量叫作<strong>最大传送单元MTU</strong>，它严格地限制着IP数据报的长度。但这对于IP数据报的传输并不是主要问题，最主要的在于发送方到目的路径上的每段链路可能使用不同的链路层协议，且每种协议可能具有不同的MTU。</p><p>解决这个问题的方法是：将IP数据报中的数据分片成两个或更多个较小的数据报，用单独的链路层帧封装这些较小的IP数据报，然后通过输出链路发送这些帧。</p><p>每个这些较小的数据报都称为<strong>片</strong>。</p><p>对于这些片的重新组合，IPv4将这项工作放在了端系统中，而不是网络路由器中。而对片的组装就需要用到<strong>标识、标志、片偏移</strong>三个字段的信息。具体如下：</p><p>①当生成一个数据报时，发送主机在为该数据报设置源和目的地址的同时贴上标识号。发送主机通常将它发送的每个数据报的标识号加1。②当某路由器需要对一个数据报分片时，形成的每个片都具有初始数据报的源地址、目的地址和标识号。③当目的地从同一发送主机收到一系列数据报时，它能够检查到数据报的标识号以确定哪些数据报实际上是同一较大数据报的片。</p><p>但IP是一种不可靠的服务，就可能出现一个或多个片永远到不了目的地。所以为了让目的主机绝对的相信它已经收到了初始数据报的最后一个片，最后一个片的标志比特被置为0，而其它所有片的标志比特被设为1。同时为了确定是否丢失了片，使用偏移字段来指定该片应放在初始IP数据报的哪个位置。</p></li><li><p>IPv4编址：在编址前要注意一点——<strong>一个IP地址是与一个接口相关联的，而不是与包括该接口的主机或路由器相关联</strong>。</p><p>它采用<strong>点分十进制记法</strong>来对IP地址进行书写。</p><p>因特网的地址分配策略被称为<strong>无类别域间路由选择（即CIDR）</strong>。当使用子网寻址时，32比特的IP地址被分为两部分，并且也具有点分十进制数形式a.b.c.d/x，其中x指示了地址的第一部分中的比特数。</p><p>形式为a.b.c.d/x的地址的x最高比特构成IP地址的网络部分，我们称之为<strong>网络前缀</strong>；剩下的32-x比特是用于区分该组织的内部设备的，其中的所有设备具有相同的网络前缀。简单的来说就是，前x位是<strong>网络号</strong>，用来表明这个IP地址是哪个网络的；后32-x位是主机号，用来区别主机。</p><p>在CIDR之前，IP地址的编制方案采用的是<strong>分类编址</strong>，网络号被限制为长度为8、16、24比特的三种，同时将这三种划分的子网分别称为A、B和C类网络。于是乎，就能够得到三类子网所能容纳的主机数量：</p><table><thead><tr><th align="center">子网类别</th><th align="center">子网主机数量</th></tr></thead><tbody><tr><td align="center"><strong>A</strong></td><td align="center"><strong>$2^8-2$</strong></td></tr><tr><td align="center"><strong>B</strong></td><td align="center"><strong>$2^{16}-2$</strong></td></tr><tr><td align="center"><strong>C</strong></td><td align="center"><strong>$2^{24}-2$</strong></td></tr></tbody></table><p>此外，还有一些特殊的地址——①255.255.255.255：广播地址；②0.0.0.0：这准确地说是一个集合——所有不清楚的主机和目的网络；③127.0.0.1：本机地址，主要用于测试；④224.0.0.1：组播地址，多用于一些特定的程序以及多媒体程序。</p></li></ul></li><li><p>一个设备是如何从某组织的地址块中分配到一个地址的？</p><p>使用<strong>动态主机配置协议（DHCP，默认端口是67/68）</strong>。DHCP允许主机自动获取一个IP地址。网络管理员能够配置DHCP，以使某给定主机每次与网络连接时能得到一个相同的IP地址，或者某主机将被分配一个<strong>临时的IP地址</strong>，每次与网络连接时该地址也可能是不同的。</p><p>DHCP是一个客户-服务器协议。客户通常是新到达的主机，它要获得包括自身使用的IP地址在内的网络配置信息。</p><p>若一台新主机想加入一个子网，DHCP通过四个步骤来实现它的网络配置：</p><ul><li><strong>DHCP服务器发现</strong>：一台新到达的主机的首要任务是发现一个要与其交互的DHCP服务器。这可以通过使用<strong>DHCP发现报文</strong>来完成。客户在UDP分组中向端口67发送该报文。发送的时候，该UDP分组是封装在一个IP数据报中的，但由于主机连最基本的所连接网络的IP地址都不知道，更不用说DHCP的服务器地址了。所以就会使用到两个特殊地址：广播地址255.255.255.255和本主机源IP地址0.0.0.0——DHCP客户生成包含DHCP发现报文的IP数据报，数据报中的两个地址就是广播地址和本主机源IP地址。在链路层中，将该数据报封装成的帧广播到该子网连接的所有节点。</li><li><strong>DHCP服务器提供</strong>：当DHCP服务器收到一个DHCP发现报文时，用<strong>DHCP提供报文</strong>向客户作出回应，DHCP提供报文也依然是向该子网的所有节点广播。每台服务器提供的报文内容包括：收到的发现报文的事务ID、向客户推荐的IP地址、网络掩码、IP地址租用期（即IP地址有效的时间量）。</li><li><strong>DHCP请求</strong>：在子网中可能有多个DHCP服务器，新主机从这些服务器中选择一个，并向选择的服务器提供用<strong>DHCP请求报文</strong>进行响应，回显配置的参数。</li><li><strong>DHCP ACK</strong>：服务器使用DHCP ACK报文对DHCP请求报文进行响应，正是所要求的参数。</li></ul><p>以《自顶而下》的DHCP客户-服务器交互为例：</p><p>①新到达的客户先广播DHCP发现报文：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">src:<span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>,<span class="hljs-number">68</span><br>dest:<span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.255</span>,<span class="hljs-number">67</span><br>DHCPDISCOVER<br>yiaddr:<span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>transaction ID:<span class="hljs-number">654</span><br></code></pre></td></tr></table></figure><p>②子网中的DHCP服务器收到DHCP发现报文后，由于不知道新主机的特定IP地址，固广播DHCP提供报文</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">src:<span class="hljs-number">255.1</span><span class="hljs-number">.2</span><span class="hljs-number">.5</span>,<span class="hljs-number">67</span><br>dest:<span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.255</span>,<span class="hljs-number">68</span><br>DHCPOFFER<br>yiaddr:<span class="hljs-number">223.1</span><span class="hljs-number">.2</span><span class="hljs-number">.4</span><br>transaction ID:<span class="hljs-number">654</span><br>DHCP server ID:<span class="hljs-number">233.1</span><span class="hljs-number">.2</span><span class="hljs-number">.5</span><br>Lifetime:<span class="hljs-number">3600</span> secs<br></code></pre></td></tr></table></figure><p>③新主机收到来自DHCP服务器的提供报文后，再向DHCP服务器发送自身的一些网络参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">src:<span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>,<span class="hljs-number">68</span><br>dest:<span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.255</span>,<span class="hljs-number">67</span><br>DHCPOFFER<br>yiaddr:<span class="hljs-number">223.1</span><span class="hljs-number">.2</span><span class="hljs-number">.4</span><br>transaction ID:<span class="hljs-number">655</span><br>DHCP server ID:<span class="hljs-number">233.1</span><span class="hljs-number">.2</span><span class="hljs-number">.5</span><br>Lifetime:<span class="hljs-number">3600</span> secs<br></code></pre></td></tr></table></figure><p>④DHCP服务器对来自新主机的请求报文进行回应</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">src:<span class="hljs-number">255.1</span><span class="hljs-number">.2</span><span class="hljs-number">.5</span>,<span class="hljs-number">67</span><br>dest:<span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.255</span>,<span class="hljs-number">68</span><br>DHCPACK<br>yiaddr:<span class="hljs-number">223.1</span><span class="hljs-number">.2</span><span class="hljs-number">.4</span><br>transaction ID:<span class="hljs-number">654</span><br>DHCP server ID:<span class="hljs-number">233.1</span><span class="hljs-number">.2</span><span class="hljs-number">.5</span><br>Lifetime:<span class="hljs-number">3600</span> secs<br></code></pre></td></tr></table></figure></li><li><p><strong>IPv6</strong>：</p><ul><li><p>IPv6数据报格式</p><p>与IPv4相比，IPv6的改进主要集中在其数据报格式中</p><ul><li><strong>扩大的地址容量</strong>：IPv6将IP地址长度从32比特扩大到了128比特，此外还引入了一种称为<strong>任播地址</strong>的新型地址（这种地址可以使数据报交付给一组主机中的任意一个）。</li><li><strong>简化高效的40字节首部</strong></li><li><strong>流标签</strong>：IPv6有一个<strong>流（flow）</strong>定义。这个字段可用于<strong>给属于特殊流的分组加上标签，这些特殊流是发送方要求进行特殊处理的流，如一种非默认服务质量或需要实时服务的流</strong>。</li></ul><p>它整个的数据报格式为（从头到尾）：</p><ul><li><strong>版本</strong>：占4比特，用于标识IP版本号。显然IPv6的这个字段就应该是6，但直接置为4并不能创建一个合法的IPv4数据报，因为其他的格式是不同的。</li><li><strong>流量类型</strong>：占8比特，与IPv4中的TOS字段相似</li><li><strong>流标签</strong>：占20比特，用于标识一条数据报的流，能够对一条流中的某些数据报给出优先权，或者能够用来对来自某些应用的数据报给出更高的优先权，以优化来自其他的应用。</li><li><strong>有效载荷长度</strong>：占16比特，且是一个无符号整数</li><li><strong>下一个首部</strong>：占8比特，用于标识数据报中的内容需要交付给哪个协议。这与IPv4首部中的协议字段值相同。</li><li><strong>跳限制</strong>：占8比特，转发数据报的每台路由器将对该字段的内容减1，直到减为0就丢弃该数据报。</li><li><strong>源地址和目的地址</strong>：各占128比特</li><li><strong>数据</strong>：IPv6数据报的有效载荷部分</li></ul><p>在IPv4中出现过的<strong>分片/重新组装</strong>、<strong>首部检验和</strong>、<strong>选项</strong>几个字段在IPv6中已不复存在。</p></li><li><p>基于IPv4的公共因特网如何迁移到IPv6？</p><p>在实践中采用最多的IPv4到IPv6的迁移方法是<strong>建隧道</strong>、<strong>双协议栈</strong>、<strong>NAT-PT（网络地址转换与协议转换）</strong>。</p><p><strong>建隧道</strong>是一种封装技术，不仅仅适用于IPv6 over IPv4，还包括其他的一种协议来传输另一种协议。简单来说就是利用一种网络传输协议，将其他协议产生的数据报文封装在自身的报文中，然后在网络中传输。它是一种虚拟的点对点的连接。</p><p>在IPv6 over IPv4的过程中，就是将IPv6的数据报报文整体放入IPv4数据报报文的数据字段中。</p></li></ul></li><li><p><strong>控制平面下的路由选择算法</strong>：从发送方到接收方的过程中确定一条通过路由器网络的好的路径。对“好路径”的解释是：具有最低开销的路径。它的分类方式有三种：</p><ul><li><p>根据算法是集中式还是分类式：</p><ul><li><p><strong>集中式路由选择算法</strong>：用完整的、全局性的网络知识计算出从源到目的地之间的最低开销路径。也就是这个算法的输入是所有节点之间的连通性及所有链路的开销。从另一个方面来说就是在算法开始计算最小的路径之前，要通过某种方式来得到这些信息。</p><p>具有全局状态信息的算法常被称作<strong>链路状态算法</strong>。</p></li><li><p><strong>分散式路由选择算法</strong>：路由器以迭代、分布式的方式计算出最低开销路径。没有节点拥有关于所有网络链路开销的完整信息，每个节点仅有与其直接相连链路的开销知识即可开始工作。然后通过迭代计算过程以及相邻节点的信息交换，一个节点逐渐计算出到达某目的节点或一组目的节点的最低开销路径。</p><p>最经典的就是<strong>距离向量算法（DV算法）</strong>，这个名字的原因是每个节点维护到网络中所有其他节点的开销估计的向量。</p></li></ul></li><li><p>根据算法是静态的还是动态的：</p><ul><li><strong>静态路由选择算法</strong>：路由随时间的变化非常缓慢，通常是人工进行调整。</li><li><strong>动态路由选择算法</strong>：随着网络流量负载或拓扑发生变化而改变路由选择路径。一个动态算法可周期性的运行或直接影响拓扑或链路开销的变化而运行。</li></ul></li><li><p>根据它是负载敏感的还是负载迟钝的</p><ul><li><strong>负载敏感算法</strong>：链路开销会动态地变化以反映出底层链路的当前拥塞水平。如果当前拥塞的一条链路与高开销相联系，则路由选择算法趋向于绕开该链路来选择路由</li><li><strong>负载迟钝算法</strong>：如今因特网路由选择算法如RIP、OSPF、BGP都是负载迟钝的，因为某条链路的开销不明确地反映其当前的拥塞水平。</li></ul></li></ul></li></ul><ul><li><p><strong>链路状态路由选择算法(LS算法)<strong>：在链路状态算法中，网络拓扑和所有的链路开销都是已知的，这些都是可以作为LS算法的输入。实践中，这是通过让每个节点向网络中所有其他节点广播链路状态分组来完成的，其中每个链路状态分组包含它所连接的链路的标识和开销。这些经常由</strong>链路状态广播</strong>算法来实现。</p><p>节点广播的结果就是所有节点都具有该网络的统一、完整的视图。</p><p>最著名的链路状态路由选择算法是<strong>Dijkstra算法</strong>，与之相密切的是<strong>Prim算法</strong>。Dijkstra算法是一种迭代算法，计算从源节点u到网络中所有其他节点的最低开销路径。k次迭代之后，就能够知道k个目的节点的最低开销路径。设置一些变量：</p><ul><li>D(v)：到算法的本次迭代，从源节点到目的节点v的最低开销路径的<strong>开销</strong></li><li>p(v)：从源到v沿着当前最低开销路径的前一节点</li><li>N`：节点子集</li></ul><p>算法思想如下：由一个初始化步骤和循环组成。循环执行的次数与网络中节点个数相同。一旦终止，该算法就计算出从源节点u到网络中每个其他节点的最短路径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化</span><br>N` = &#123;u&#125;<br><span class="hljs-keyword">for</span> all nodes v<br>    <span class="hljs-keyword">if</span> v is a neighbor of u<br>        the <span class="hljs-built_in">D</span>(v) = <span class="hljs-built_in">c</span>(u, v)<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">D</span>(v) = ∞<br>        <br><span class="hljs-comment">// 循环</span><br>Loop<br>find w <span class="hljs-keyword">not</span> in N` such that <span class="hljs-built_in">D</span>(w) is a minimum<br>add w to N`<br>update <span class="hljs-built_in">D</span>(v) <span class="hljs-keyword">for</span> each neighbor v of w <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> in N`:<br><span class="hljs-built_in">D</span>(v) = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">D</span>(v), <span class="hljs-built_in">D</span>(w)+<span class="hljs-built_in">c</span>(w,v))<br>until N` = N<br></code></pre></td></tr></table></figure></li><li><p><strong>距离向量路由选择算法(DV算法)<strong>：这是一种迭代的、异步的、分布式的算法。</strong>分布式</strong>是因为每个节点都要从一个或多个直接相连邻居接收某些信息，执行计算，然后将计算结果分发给邻居。<strong>迭代</strong>是因为此过程一直要持续到邻居之间无更多的信息要交换为止。<strong>异步</strong>是因为它不要求所有节点相互之间步伐一致地操作。</p><p>在算法之前，先提出最低开销路径与著名的Bellman-Ford相关。设$d_{x}(y)$是从节点x到节点y地最低开销路径：<br>$$<br>d_{x}(y) = min_{v}\left{ c(x,v) +  d_{v}(y)\right}<br>$$<br>这个方程还提出了在DV算法中发生的邻居到邻居通信的形式。其基本思想是：</p><p>每个节点x以$D_{x}(y)$开始，对在N中的所有节点y，估计从x到y的最低开销路径的开销。令$D_{x} = [D_{x}(y):y∈N]$是节点x的距离向量，该向量是从x到在N中的所有其他节点y的开销估计向量。</p><p>使用DV算法，，每个节点x维护下列路由选择信息：</p><ul><li>对于每个邻居v，从x到直接相连邻居v的开销为$c(x,v)$</li><li>节点x的距离向量，即$D_{x} = [D_{x}(y):y∈N]$，包含了x到N中所有目的地y的开销估计值</li><li>它的每个邻居的距离向量，即对x的每个邻居v，有$D_{v} = [D_{v}(y):y∈N]$​</li></ul><p>在DV算法中，每个节点不时地向它的每个邻居发送它的距离副本。每当节点从它的邻居那儿接收到一个新距离向量，它保存这个距离向量，并使用Bellman-Ford方程来更新它自己的距离向量。算法具体如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 对每个节点x</span><br>Initialization:<br><span class="hljs-keyword">for</span> all destinations y in N:<br><span class="hljs-built_in">Dx</span>(y) = <span class="hljs-built_in">c</span>(x,y) <span class="hljs-comment">// if y is not a neighbor then c(x,y) = ∞</span><br>    <span class="hljs-keyword">for</span> each neighbor w<br>        <span class="hljs-built_in">Dw</span>(y) = ? <span class="hljs-keyword">for</span> all destinations y in N<br>    <span class="hljs-keyword">for</span> each neighbor w<br>        send distance vector Dx = [<span class="hljs-built_in">Dx</span>(y):y in N] to w<br>    <br>loop<br><span class="hljs-built_in">wait</span> (until I see a link coost change to some neighbor w <span class="hljs-keyword">or</span> until I receive a distance vector from spm nieghbirs w)<br>    <br>    <span class="hljs-keyword">for</span> each y in N<br>        <span class="hljs-built_in">Dx</span>(y) = min_v&#123;<span class="hljs-built_in">c</span>(x,v) + <span class="hljs-built_in">Dv</span>(y)&#125;<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">Dx</span>(y) changed <span class="hljs-keyword">for</span> any destination y<br>    send distance vector Dx = [<span class="hljs-built_in">Dx</span>(y):y in N] to all neighbors<br></code></pre></td></tr></table></figure></li><li><p><strong>ISP之间的路由选择：BGP</strong></p><p>BGP协议，全称为边界网关协议，是所有的AS所运行的相同的AS<strong>间</strong>路由选择协议。它异常重要，因为正是它将因特网中数以千计的ISP黏合起来。BGP是一种分布式和异步的协议，这一点与距离向量路由选择协议相同。</p><ul><li><p>BGP的作用：在BGP中，分组并不是路由到一个特定的目的地址，是路由到CIDR化的前缀（每个前缀表示一个子网或一个子网集合）。它为每一台路由提供一种完成以下任务的手段：</p><ul><li><p><strong>从邻居AS获得前缀的可达性信息</strong>：BGP允许每个子网向因特网的其余部分通告它的存在。也就是如果没有BGP，每个子网将是隔离的孤岛，它们将会是孤独的存在，不为因特网其余部分所知和所达。</p><p>具体如下：</p><p>对于每个AS，每台路由器要么是一台<strong>网关路由器</strong>，要么是一台<strong>内部路由器</strong>。网关路由器是一台位于AS边缘的路由器它直接连接到在其他AS中的一台或多台路由器。内部路由器仅连接在它自己AS中的主机和路由器。在BGP中，每对路由器通过使用<strong>179</strong>端口的半永久TCP连接交换路由选择信息。每条直接连接以及所有通过该连接发送的BGP报文，称为<strong>BGP连接</strong>。其中，跨越两个AS的BGP连接称为<strong>外部BGP（eBGP）连接</strong>，在相同AS中的两台路由器之间的BGP会话称为<strong>内部BGP（iBGP）连接</strong>。</p></li><li><p><strong>确定到该前缀的最好的路由</strong>：为了确定最好的路由，路由器将在本地运行一个BGP路由选择过程。该最好的路由将基于策略以及可达性信息来确定。</p><p>具体如下：</p><p>当路由器通过BGP连接通告前缀时，它在前缀中包括一些<strong>BGP属性</strong>；用BGP术语来说，前缀及其属性称为<strong>路由</strong>；AS-PATH属性包括了通告已经通过的AS的列表；NEXT-HOP是AS-PATH起始的路由器接口的IP地址。</p><p>为了生成AS-PATH的值，当一个前缀通过某AS时，AS将其ASN加入AS-PATH中的现有列表。同时BGP路由器还能使用AS-PATH属性来检测和防止通告环路。</p></li></ul></li><li><p>BGP路由选择算法：</p><ul><li><p><strong>热土豆路由选择</strong>：选择具有最小最低开销的网关。</p><p>在一台路由器转发表中对于热土都路由选择增加AS向外前缀的步骤就为：</p><p>①从AS间协议学到多个网关可达子网x</p><p>②使用来自AS内部协议的路由选择信息，以决定到达每个网关的最低开销路径的开销</p><p>③热土豆路由选择：选择具有最小最低开销的网关</p><p>④从转发表确定通往最低开销网关的接口I。在转发表中加入表项(x,I)</p><p>热土豆路由选择的依据是：对于一个路由，尽可能的将分组送出其AS，并不担心其AS外部到目的地的余下部分的开销。</p><p>这是一种<strong>自私</strong>的算法，因为这种算法试图减小在它自己AS中的开销，而忽略在其AS之外的端到端的开销的其他部分。</p></li><li><p><strong>路由器选择算法</strong>：对于任何给定的目的地前缀，进入BGP的路由选择算法的输入是到某前缀的所有路由的集合，该前缀是已被路由器学习和接受的。如果到相同的前缀有两条或多条路由，则依次调用下列消除规则直到余下一条路由：</p><ul><li>路由被指派一个<strong>本地偏好</strong>值作为其属性之一。本地偏好属性的值是一种策略决定，它完全取决于该AS的网络管理员。具有最高本地偏好值的路由将被选择。</li><li>从余下的路由中，将选择具有最短AS-PATH的路由。如果该规则是路由选择的唯一规则，则BGP将使用距离向量算法来决定路径，其中距离测度使用AS跳的跳数而不是路由器跳的跳数。</li><li>从余下的路由中使用热土豆路由选择，即选择具有最靠近NEXT-HOP路由器的路由</li><li>如果还余留有多条路由，该路由器使用BGP标识符来选择路由。</li></ul></li></ul></li><li><p>BGP实现的IP任播：这种服务通常用于DNS中。IP任播主要服务于①在许多分散的不同地理位置，替换不同服务器上的相同内容；②让每个用户从最靠近的服务器访问内容。</p></li></ul></li><li><p>SDN控制平面：控制分组在网络的SDN使能设备中转发的网络范围逻辑，以及这些设备和它们的服务的配置与管理。SDN体系结构有四个关键特征：</p><ul><li><strong>基于流的转发</strong>：SDN控制的交换机的分组转发工作，能够基于运输层、网络层或链路层首部中任意数量的首部字段进行转发。SDN控制平面的工作是计算、管理和安装所有网络交换机中的流表项。</li><li><strong>数据平面与控制平面分离</strong>：数据平面由网络交换机组成，控制平面由服务器以及决定和管理交换机流表项的组成。</li><li><strong>网络控制功能</strong>：位于数据平面交换机外部。控制平面自身有两个组件组成：一个SDN控制器和若干网络控制应用程序。</li><li><strong>可编程的网络</strong>：网络的可编程性是通过运行在控制平面中的网络控制应用程序来实现。</li></ul><p>SDN表示了一种意义重大的网络功能的“分类”，即数据平面交换机、SDN控制器和网络控制应用程序是分离的实体。</p><p>SDN控制平面大体划分为两个部分：SDN控制器和SDN网络控制应用程序。</p><ul><li><p>SDN控制器大体分为3个层次：</p><ul><li><strong>通信层</strong>：SDN控制器和受控网络设备之间的通信。通过OpenFlow或者SNMP等协议能够实现传送控制器与SDN使能交换机、主机或其他设备之间的信息。这些协议构成了控制器体系结构的最底层。控制器与受控设备之间的通信跨越了一个接口，被称为控制器的<strong>“南向”接口</strong>。</li><li><strong>网络范围状态管理层</strong>：有SDN控制平面所做出的最终控制决定，将要求控制器具有有关网络的主机、链路、交换机和其他SDN控制设备的最新状态信息。</li><li><strong>对于网络控制应用程序层的接口</strong>：控制器通过它的<strong>“北向“接口</strong>与网络控制应用程序交互。该API允许网络控制应用程序在状态管理层之间读/写网络状态和流表。</li></ul></li><li><p>OpenFlow协议：</p><p>运行在TCP之上，使用6653的默认端口号。OpenFlow的报文种类有：</p><p>①从控制器到受控交换机流动的重要报文：</p><ul><li><strong>配置</strong>：允许控制器查询并设置交换机的配置参数</li><li><strong>修改状态</strong>：由控制器所使用，以增加/删除或修改交换机流表中的表项，并设置交换机端口特性</li><li><strong>读状态</strong>：被控制器用于从交换机的流表和端口收集统计数据和计数器值</li><li><strong>发送分组</strong>：被控制器用于在受控交换机从特定的端口发送出一个特定的报文</li></ul><p>②从受控交换机到控制器流动的重要报文：</p><ul><li><strong>流删除</strong>：通知控制器已删除一个流表项</li><li><strong>端口状态</strong>：交换机使用该报文向控制器通知端口状态的变化</li><li><strong>分组入</strong>：被用于将分组发送给控制器。</li></ul></li><li><p>ICMP协议：</p><p>ICMP最典型的用途是差错报文。通常将ICMP视为IP的一部分，但在体系上，却又高于IP一级，因ICMP报文时作为IP有效载荷承载的。</p><p>经典的Traceroute程序就是使用的ICMP报文。</p></li><li><p>网络管理和SNMP：</p><ul><li>网络管理框架：<ul><li><strong>管理服务器</strong>：是执行网络管理活动的地方，控制网络管理信息的收集、处理、分析和显示</li><li><strong>被管设备</strong>：网络装备的一部分，位于被管理的网络中。</li><li><strong>管理信息库（MIB）</strong>：一个被管设备中的每个被管对象的关联信息都收集在MIB中，这些信息的值是供管理服务器所用的。</li><li><strong>网络管理代理</strong>：是运行在被管设备中的一个<strong>进程</strong>，该进程与管理服务器通信，在管理服务器的命令和控制下在被管设备中采取本地动作。</li><li><strong>网络管理协议</strong>：该协议运行在管理服务器和被管设备之间，允许管理服务器查询被管设备的状态，并经过其代理间接地在这些设备上采取行动。代理能够使用网络管理协议向管理服务器通知异常事件。网络管理协议是不能自己管理网络的，它只能使网络管理员有能力去管理网络。</li></ul></li><li>SNMP：简单网络管理协议，这是一个应用层协议，用于管理服务器和代表管理服务器执行的代理之间传递网络管理控制和信息报文。最常用的是请求响应模式，SNMP管理服务器向SNMP代理发送一个请求，这个请求通常用于查询或修改与某被管设备关联的MIB对象值，代理接收到该请求后，执行某些动作，然后对该请求发送一个回答。SNMP的另外一个使用是代理向管理服务器发送的一种非请求报文，这种报文被称为<strong>陷阱报文</strong>。这种报文用于通知管理服务器有一个异常情况已经导致MIB对象值的改变。在SNMP v2中一共有7种类型的报文：<ul><li>管理服务器向代理发送的报文：GetRequest、GetNextRequest、GetBulkRequest PDU。通过这三种报文，管理服务器能够获得该代理所在被管设备中的一个或多个MIB对象值。三者的区别在于它们的数据请求粒度：GetRequest请求的是MIB值的任意集合，多个GetNextRequest是顺序地读取MIB对象的列表或表格，GetBulkRequest允许读取大块数据。</li><li>SetRequest PDU被管理服务器用来设置位于被管设备中的一个或多个MIB对象的值</li><li>InformRequest PDU被管理服务器用来通知另一个MIB信息管理服务器</li><li>Response PDU是被管设备发送给管理服务器的，以响应来自该服务器的请求报文，返回所请求的信息。</li><li>陷阱报文：是异步产生的，也就是说它们不是为了响应接收到的请求而产生的，而是为了响应管理服务器要求通知的事件而产生的。</li></ul></li></ul></li></ul></li></ul><h1 id="第五章-链路层与局域网"><a href="#第五章-链路层与局域网" class="headerlink" title="第五章 链路层与局域网"></a>第五章 链路层与局域网</h1><ul><li><p>链路层的信道有两种：一种是广播信道，用于连接有线局域网、卫星网、混合光纤同轴电缆接入网中的多台主机。另一种是点对点通信链路，在长距离链路连接的两台路由器之间。</p></li><li><p>链路层的服务：</p><ul><li><strong>成帧</strong>：一个帧由一个数据字段和若干首部字段组成。</li><li><strong>链路接入</strong>：MAC（媒体访问控制）协议规定了帧在链路上传输的规则，简单来说就是只要链路空闲，无论何时发送方都能发送帧。</li><li><strong>可靠交付</strong>：保证无差错的经链路层移动每个网络层数据报。与TCP类似，链路层的可靠交付通常是通过确认和重传取得的。通常应用于容易产生高差错率的链路。</li><li><strong>差错检测和纠正</strong>：是为了解决有信号衰减和电磁噪声导致的比特差错。</li></ul></li><li><p>链路层的主体部分是在网络适配器（或称为网络接口卡）中实现的，它是软件与硬件的结合体，也就说明链路层是协议栈中软件与硬件交接的地方。</p></li><li><p>差错检测和纠正技术：对从一个节点到另一个物理上连接的邻近节点的链路层帧中的比特损伤进行检测和纠正。有三种检验差错的技术：</p><ul><li><p><strong>奇偶检验</strong>：单个奇偶检验位是最简单的方法。它分为偶检验和奇检验：</p><ul><li>偶检验：对于一个要发送的d比特的信息D，发送方需要包含一个附加的比特，并选择它的值，使得d+1的比特中1的个数是偶数</li><li>奇检验：与偶检验相比，区别在于要使d+1的比特中1的个数是奇数</li></ul><p>但单个比特奇偶检验保护的一帧中未检测出差错的概率只有50%。所以就在其基础上发展出了改进方法：二维奇偶检验。具体的是：将信息D的d个比特划分为i行j列，对每行每列计算奇偶值，产生的i+j+1奇偶比特构成了链路成帧的差错检测比特。一旦信息的比特出现差错，那么它的某一行和列的奇偶值都会变化，从而确定哪一个比特发生了错误。</p></li><li><p><strong>检验和方法</strong>：在这种技术中，d比特数据被作为一个k比特整数的序列来处理。最简单的检验和方法就是将这k比特整数加起来，并且用得到的和作为差错检测比特。TCP和UDP所使用的<strong>因特网检验和</strong>就是基于的这种方法。</p></li><li><p><strong>循环冗余检测</strong>：这是最广泛使用的差错检测技术，基于的是<strong>循环冗余检测编码，即CRC编码</strong>。 CRC编码也被称为多项式编码。具体如下：</p><p>①有d比特的数据D，发送方先与接收方协商一个r+1比特模式，也就是<strong>生成多项式</strong>，命名为G。对G的要求是最高有效位的比特必须是1；</p><p>②发送方选择r个附加比特R，并将其附加在D上，整个长度就变为d+r比特；</p><p>③对①②中的两个序列进行模2算术；</p><p>④如果余数为0，那么就无差错，否则就有。</p></li></ul></li><li><p>具有碰撞检测的载波侦听多路访问协议（CSMA/CD）：它包含两个重要的规则——<strong>载波侦听</strong>：一个节点在传输前先听信道；<strong>碰撞检测</strong>：当一个传输节点在传输时一直在侦听此信道。</p><ul><li>CSMA/CD效率：将这个效率定义为当有大量的活跃节点且每个节点有大量的帧要发送时，帧在信道中无碰撞地传输的那部分时间在长期运行时间中所占的份额。</li></ul></li><li><p>CSMA/CD协议是多路访问协议的一种，ALOHA协议同样也是。多路访问协议最理想的特性是①当只有一个节点活跃时，该活跃节点具有R bps的吞吐量和；②当有M个节点活跃时，每个活跃节点的吞吐量接近R/M bps。CSMA/CD和ALOHA都只具备第一个特性。所以在此基础上创造了<strong>轮流协议</strong>。准确说它也是一种协议簇。</p><ul><li>第一种轮流协议：<strong>轮询协议</strong>。它要求这些节点之一被指定为主节点，主节点以循环的方式轮询每个节点。这种协议消除了困扰随机接入协议的碰撞和空时隙，提高了效率。但它有两个严重的缺点：①这种协议产生了一个新的时延——轮询时延；②如果所选的主节点一旦出现故障，那么整个信道都会变得不可操作。</li><li>第二种轮流协议：<strong>令牌传递协议</strong>。这种协议中没有主节点，而是增加了一个称为<strong>令牌</strong>的小的特殊<strong>帧</strong>。在节点之间以某种固定的次序进行交换。它的缺点在于如果一个节点忘记了释放令牌，那么就需要调用某些恢复步骤来使令牌返回到循环中。</li></ul></li><li><p>MAC地址：链路层地址，也叫LAN地址或物理地址。 MAC地址占6个字节，通常使用十六进制表示法，每个字节被表示为一对十六进制数。</p></li><li><p>ARP协议：地址解析协议。是将一个IP地址解析为MAC地址，类似于DNS（DNS是将主机名解析为IP地址）。两者的区别在于前者只能在同一个子网上的主机和路由器接口解析IP地址，而后者能在因特网中的任何地方的主机解析主机名。通过查询每台主机或路由器中的ARP表，能够得到IP地址到MAC地址的映射关系。在这张表中还存储了从表中删除每个映射的时间。</p><p>当ARP表中没有我们需要的映射关系时，发送方先构造一个称为<strong>ARP分组</strong>的特殊分组，它包括了发送和接收IP地址和MAC地址。ARP查询分组和响应分组都具有相同的格式。ARP查询分组的目的是询问子网上所有其他主机和路由器，所以会指示适配器使用MAC广播地址，以确定对应于要解析的IP地址的那个MAC地址。</p><p>在广播这个分组的过程中，适配器在链路层帧中封装这个ARP分组，用广播地址作为帧的目的地址，并将该帧传输进子网中。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记/计网</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
